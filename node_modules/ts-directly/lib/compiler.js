async function swcCompiler() {
    const swc = await import("@swc/core");
    return async (code, filename, opts) => {
        const { target = "es2022", module = "esnext", experimentalDecorators, useDefineForClassFields, } = opts;
        const options = {
            filename,
            module: {
                importInterop: opts.esModuleInterop ? "swc" : "none",
                type: module === "commonjs" ? "commonjs" : "es6",
            },
            sourceMaps: "inline",
            inlineSourcesContent: false,
            swcrc: false,
            jsc: {
                target: target === "esnext" ? "es2022" : target,
                externalHelpers: opts.importHelpers,
                minify: {
                    compress: false,
                    mangle: false,
                },
                parser: {
                    decorators: experimentalDecorators,
                    syntax: "typescript",
                    tsx: filename.endsWith("x"),
                },
                transform: {
                    useDefineForClassFields,
                    legacyDecorator: experimentalDecorators,
                    decoratorMetadata: opts.emitDecoratorMetadata,
                },
            },
        };
        options.jsc.transform.react = {
            runtime: opts.jsx?.startsWith("react-") ? "automatic" : "classic",
            pragma: opts.jsxFactory,
            pragmaFrag: opts.jsxFragmentFactory,
            importSource: opts.jsxImportSource ?? "react",
        };
        return (await swc.transform(code, options)).code;
    };
}
async function esbuildCompiler() {
    const esbuild = await import("esbuild");
    return async (code, sourcefile, compilerOptions) => {
        const { target, module } = compilerOptions;
        const options = {
            sourcefile,
            tsconfigRaw: { compilerOptions },
            target,
            loader: sourcefile.endsWith("x") ? "tsx" : "ts",
            sourcemap: "inline",
            sourcesContent: false,
        };
        if (module === "commonjs") {
            options.format = "cjs";
        }
        return (await esbuild.transform(code, options)).code;
    };
}
async function sucraseCompiler() {
    const { transform } = await import("sucrase");
    return (input, filePath, opts) => {
        const transforms = ["typescript"];
        if (filePath.endsWith("x")) {
            transforms.push("jsx");
        }
        if (opts.module === "commonjs") {
            transforms.push("imports");
        }
        const { code, sourceMap } = transform(input, {
            filePath,
            transforms,
            keepUnusedImports: opts.verbatimModuleSyntax,
            sourceMapOptions: { compiledFilename: filePath },
            preserveDynamicImport: true,
            disableESTransforms: true,
            injectCreateRequireForImportRequire: true,
            enableLegacyTypeScriptModuleInterop: !opts.esModuleInterop,
            jsxRuntime: opts.jsx?.startsWith("react-") ? "automatic" : "classic",
            production: opts.jsx !== "react-jsxdev",
            jsxImportSource: opts.jsxImportSource,
            jsxPragma: opts.jsxFactory,
            jsxFragmentPragma: opts.jsxFragmentFactory,
        });
        const base64 = Buffer.from(JSON.stringify(sourceMap)).toString("base64");
        return `${code}\n//# sourceMappingURL=data:application/json;base64,${base64}`;
    };
}
async function tscCompiler() {
    const { default: ts } = await import("typescript");
    return (code, fileName, compilerOptions) => {
        const opts = { fileName, compilerOptions };
        return ts.transpileModule(code, opts).outputText;
    };
}
export const compilers = [swcCompiler, esbuildCompiler, sucraseCompiler, tscCompiler];
export const names = ["swc", "esbuild", "sucrase", "tsc"];
export async function detectTypeScriptCompiler() {
    const name = process.env.TS_COMPILER;
    if (name) {
        const index = names.indexOf(name);
        if (index === -1) {
            throw new Error(`Invalid TS_COMPILER value: ${name}`);
        }
        return compilers[index]();
    }
    for (const create of compilers) {
        try {
            return await create();
        }
        catch (e) {
            if (e.code !== "ERR_MODULE_NOT_FOUND")
                throw e;
        }
    }
    throw new Error("No supported TypeScript compiler found");
}
//# sourceMappingURL=compiler.js.map