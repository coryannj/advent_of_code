import { fileURLToPath, pathToFileURL } from "url";
import { dirname, join, sep } from "path";
import { readFileSync } from "fs";
import { detectTypeScriptCompiler } from "./compiler.js";
import { getAlias, getTSConfig } from "./tsconfig.js";
export const typeCache = new Map();
const addToCache = (k, v) => (typeCache.set(k, v), v);
const node_modules = sep + "node_modules";
function getPackageType(filename) {
    const dir = dirname(filename);
    const cached = typeCache.get(dir);
    if (cached) {
        return cached;
    }
    try {
        const json = readFileSync(join(dir, "package.json"), "utf8");
        return addToCache(dir, JSON.parse(json).type ?? "commonjs");
    }
    catch (e) {
        if (e.code !== "ENOENT")
            throw e;
    }
    if (!dir || dir.endsWith(node_modules)) {
        return addToCache(dir, "commonjs");
    }
    else {
        return addToCache(dir, getPackageType(dir));
    }
}
function detectModuleType(filename) {
    const i = filename.lastIndexOf(".") + 1;
    if (i === 0) {
        throw new Error(`${filename} is not a module`);
    }
    switch (filename.charCodeAt(i)) {
        case 99:
            return "commonjs";
        case 109:
            return "module";
        default:
            return getPackageType(filename);
    }
}
let importedCompileFn;
export async function transform(code, filename, format) {
    importedCompileFn ??= await detectTypeScriptCompiler();
    const found = await getTSConfig(filename);
    if (!found) {
        throw new Error(`Cannot find tsconfig.json for ${filename}`);
    }
    const compilerOptions = { ...found.tsconfig.compilerOptions };
    if (format === "module") {
        const { module = "" } = compilerOptions;
        if (!module.startsWith("es")) {
            compilerOptions.module = "esnext";
        }
    }
    else if (format === "commonjs") {
        compilerOptions.module = "commonjs";
    }
    else {
        format = detectModuleType(filename);
    }
    switch (compilerOptions.module) {
        case "node16":
        case "nodenext":
            compilerOptions.module = format === "module" ? "esnext" : "commonjs";
    }
    return {
        shortCircuit: true,
        format,
        source: await importedCompileFn(code, filename, compilerOptions),
    };
}
export const resolve = async (specifier, context, nextResolve) => {
    const paths = await getAlias(specifier, context.parentURL);
    for (const path of paths) {
        if (path.endsWith(".d.ts")) {
            continue;
        }
        const url = pathToFileURL(path).href;
        try {
            return await doResolve(url, context, nextResolve);
        }
        catch (e) {
            if (e.code !== "ERR_MODULE_NOT_FOUND")
                throw e;
        }
    }
    return doResolve(specifier, context, nextResolve);
};
function throwIfModuleIsFound(e, specifier) {
    if (e.code !== "ERR_MODULE_NOT_FOUND") {
        throw e;
    }
    e.specifier ??= specifier;
    if (e.specifier !== specifier)
        throw e;
}
const doResolve = async (specifier, context, nextResolve) => {
    try {
        return await nextResolve(specifier, context);
    }
    catch (e) {
        throwIfModuleIsFound(e, specifier);
        const isFile = /^(?:file:|\.{0,2}\/)/i.test(specifier);
        if (!isFile || !/\.[cm]?jsx?$/i.test(specifier)) {
            throw e;
        }
        const tsSource = specifier.at(-1) !== "x"
            ? specifier.slice(0, -2) + "ts"
            : specifier.slice(0, -3) + "tsx";
        try {
            return await nextResolve(tsSource, context);
        }
        catch (e) {
            throwIfModuleIsFound(e, specifier);
        }
        throw e;
    }
};
export const load = async (url, context, nextLoad) => {
    if (context.format === "json") {
        context.importAttributes.type = "json";
        return nextLoad(url, context);
    }
    const match = /\.[cm]?tsx?$/i.test(url);
    if (!match || !url.startsWith("file:")) {
        return nextLoad(url, context);
    }
    context.format = "ts";
    const loaded = await nextLoad(url, context);
    return transform(loaded.source.toString(), fileURLToPath(url));
};
//# sourceMappingURL=loader.js.map