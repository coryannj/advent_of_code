import { mean, quantileSorted, standardDeviation } from "simple-statistics";
import { TukeyOutlierDetector } from "./math.js";
import { MetricAnalysis } from "./profiling.js";
import { variablesToString } from "./utils.js";
import { Summary } from "./summary.js";
import formatSummaryTable from "./format.js";
const kProcessedMetrics = Symbol();
const kRowNumber = Symbol();
function getMetrics(item) {
    return item[kProcessedMetrics];
}
function styleRatio(v, p, style, meta) {
    let text;
    let x = v / p;
    if (p === 0) {
        // Cannot divide by 0 to calculate the ratio, but it is still comparable.
        text = v === 0 ? "equal" : v > p ? "greater" : "less";
    }
    else if (style === "trend") {
        text = `${(x * 100).toFixed(2)}%`;
    }
    else if (style === "value") {
        text = `${x.toFixed(2)}x`;
    }
    else {
        x = (x - 1) * 100;
        text = x > 0 ? `+${x.toFixed(2)}%` : `${x.toFixed(2)}%`;
    }
    return [text, v === p ? null : (v < p === meta.lowerIsBetter) ? "green" : "red"];
}
class RowNumberColumn {
    name = "No.";
    index = 0;
    getValue(data) {
        data[kRowNumber] = this.index;
        return (this.index++).toString();
    }
}
class VariableColumn {
    name;
    constructor(key) {
        this.name = key;
    }
    getValue(data) {
        return data[this.name];
    }
}
class RawMetricColumn {
    meta;
    name;
    constructor(meta) {
        this.meta = meta;
        this.name = meta.key;
    }
    get format() {
        return this.meta.format;
    }
    getValue(data) {
        const metric = getMetrics(data)[this.name];
        return Array.isArray(metric) ? mean(metric) : metric;
    }
}
class StatisticsColumn {
    meta;
    constructor(meta) {
        this.meta = meta;
    }
    get format() {
        return this.meta.format;
    }
    getValue(data) {
        const { key } = this.meta;
        const values = getMetrics(data)[key];
        if (Array.isArray(values)) {
            return this.calculate(values);
        }
        if (values !== undefined) {
            throw new TypeError(`Metric "${key}" must be an array`);
        }
    }
}
class StdDevColumn extends StatisticsColumn {
    get name() {
        return this.meta.key + ".SD";
    }
    calculate(values) {
        return standardDeviation(values);
    }
}
class PercentileColumn extends StatisticsColumn {
    p;
    constructor(meta, p) {
        super(meta);
        this.p = p;
    }
    get name() {
        return `${this.meta.key}.p${this.p}`;
    }
    calculate(values) {
        return quantileSorted(values, this.p / 100);
    }
}
class BaselineColumn {
    meta;
    variable;
    value;
    style;
    ratio1;
    constructor(meta, baseline, style) {
        this.meta = meta;
        this.variable = baseline.type;
        this.value = baseline.value;
        this.style = style;
    }
    get name() {
        return this.meta.key + ".ratio";
    }
    toNumber(data) {
        const metric = getMetrics(data)[this.meta.key];
        return Array.isArray(metric) ? mean(metric) : metric;
    }
    prepare(cases) {
        const { variable, value } = this;
        const row = cases.find(i => i[variable] === value);
        this.ratio1 = row && this.toNumber(row);
    }
    getValue(data) {
        const { variable, value, ratio1, meta, style } = this;
        if (data[variable] === value) {
            return "baseline";
        }
        const v = this.toNumber(data);
        if (v === undefined || ratio1 === undefined) {
            return;
        }
        return styleRatio(v, ratio1, style, meta);
    }
}
class DifferenceColumn {
    another;
    meta;
    style;
    constructor(another, meta, style) {
        this.another = another;
        this.meta = meta;
        this.style = style;
    }
    get name() {
        return `${this.meta.key}.diff`;
    }
    toNumber(data) {
        const metric = data[this.meta.key];
        return Array.isArray(metric) ? mean(metric) : metric;
    }
    getValue(data) {
        const previous = this.another.find(data);
        if (!previous) {
            return;
        }
        const p = this.toNumber(getMetrics(previous));
        const c = this.toNumber(getMetrics(data));
        if (p === undefined || c === undefined) {
            return;
        }
        return styleRatio(c, p, this.style, this.meta);
    }
}
function preprocess(summary, options) {
    const { outliers = "all" } = options;
    for (const item of summary.results) {
        const rawMetrics = Summary.getMetrics(item);
        const metrics = Object.create(rawMetrics);
        item[kProcessedMetrics] = metrics;
        for (const meta of summary.meta.values()) {
            const value = metrics[meta.key];
            if (!Array.isArray(value)) {
                continue;
            }
            value.sort((a, b) => a - b);
            if (outliers && meta.analysis === 2) {
                removeOutliers(summary, outliers, item, meta);
            }
        }
    }
}
function removeOutliers(summary, outliers, row, meta) {
    const before = row[kProcessedMetrics][meta.key];
    const mode = outliers === "all"
        ? "all"
        : (outliers === "best") === meta.lowerIsBetter
            ? "lower" : "upper";
    const after = new TukeyOutlierDetector(before).filter(before, mode);
    row[kProcessedMetrics][meta.key] = after;
    const removed = before.length - after.length;
    if (removed !== 0) {
        summary.notes.push({ type: "info", case: row, text: `${removed} outliers were removed.` });
    }
}
export class SummaryTable {
    formats;
    groupEnds = [];
    colors = [];
    /**
     * Content of the table, the first row is header.
     */
    cells = [];
    hints = [];
    warnings = [];
    /**
     * Build SummaryTable of a suite from its benchmark result.
     *
     * @param result Results of the suite with toolchains.
     * @param diff Used to generate *.diff columns.
     * @param options The options, see its type for details.
     */
    static from(result, diff, options = {}) {
        const { stdDev = true, percentiles = [], ratioStyle = "percentage" } = options;
        const summary = new Summary(result);
        const prev = new Summary(diff || []);
        const { baseline } = summary;
        const columnDefs = [new RowNumberColumn()];
        for (const [p, v] of summary.vars.entries()) {
            if (options.showSingle || v.size > 1) {
                columnDefs.push(new VariableColumn(p));
            }
        }
        for (const meta of summary.meta.values()) {
            columnDefs.push(new RawMetricColumn(meta));
            if (!meta.analysis /* None or undefined */) {
                continue;
            }
            if (meta.analysis === MetricAnalysis.Statistics) {
                if (stdDev) {
                    columnDefs.push(new StdDevColumn(meta));
                }
                for (const k of percentiles) {
                    columnDefs.push(new PercentileColumn(meta, k));
                }
            }
            if (baseline) {
                const { type, value } = baseline;
                // Variable names should be consistent and cannot be filtered,
                const values = summary.vars.get(type);
                if (!values) {
                    const vs = variablesToString(summary.vars);
                    throw new Error(`Baseline (${type}) is not in variables:\n${vs}`);
                }
                // When using filters, the value may not in the results.
                if (values.has(value)) {
                    columnDefs.push(new BaselineColumn(meta, baseline, ratioStyle));
                }
                else {
                    summary.notes.push({
                        type: "warn",
                        text: `Baseline { ${type}: ${value} } does not in the results.`,
                    });
                }
            }
            // Assume the meta has not changed.
            if (prev.meta.has(meta.key)) {
                columnDefs.push(new DifferenceColumn(prev, meta, ratioStyle));
            }
        }
        preprocess(summary, options);
        preprocess(prev, options);
        return new SummaryTable(summary, columnDefs);
    }
    constructor(summary, columnDefs) {
        this.formats = columnDefs.map(c => c.format);
        let colorRow;
        let row;
        const addRow = () => {
            this.cells.push(row = []);
            this.colors.push(colorRow = []);
        };
        function push(v) {
            if (v === undefined) {
                row.push(undefined);
                colorRow.push(null);
            }
            else if (Array.isArray(v)) {
                row.push(v[0]);
                colorRow.push(v[1]);
            }
            else {
                row.push(v);
                colorRow.push(null);
            }
        }
        addRow();
        for (const column of columnDefs) {
            push(column.name);
        }
        const rawGroups = summary.baseline
            ? summary.split(summary.baseline.type).values()
            : [summary.results];
        for (const group of rawGroups) {
            for (const metricColumn of columnDefs) {
                metricColumn.prepare?.(group);
            }
            for (const result of group) {
                addRow();
                for (const column of columnDefs) {
                    push(column.getValue(result));
                }
            }
            this.groupEnds.push(this.cells.length);
        }
        const { hints, warnings } = this;
        for (const note of summary.notes) {
            const c = note.case;
            const scope = c ? `[No.${c[kRowNumber]}] ${c.Name}: ` : "";
            const message = scope + note.text;
            (note.type === "info" ? hints : warnings).push(message);
        }
    }
    /**
     * Format the table for better presentation, it will perform:
     * - Add an empty line between groups.
     * - Convert numeric values to string with units if possible.
     * - Apply colors to cells, using `options.stainer`.
     */
    format(options) {
        return formatSummaryTable(this, options);
    }
}
//# sourceMappingURL=table.js.map