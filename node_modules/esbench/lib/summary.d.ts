import { ResultBaseline } from "./runner.js";
import { MetricMeta, Metrics } from "./profiling.js";
import { ToolchainResult } from "./connect.js";
declare const kMetrics: unique symbol;
declare const kIndex: unique symbol;
export type FlattedResult = Record<string, string> & {
    [kMetrics]: Metrics;
    [kIndex]: number;
    [customKeys: symbol]: any;
};
export interface ResolvedNote {
    type: "info" | "warn";
    text: string;
    case?: FlattedResult;
}
export declare class Summary {
    /**
     * All variable names and each of their possible values.
     */
    readonly vars: Map<string, Set<string>>;
    /**
     * Descriptions of metrics.
     *
     * @see ProfilingContext.meta
     */
    readonly meta: Map<string, MetricMeta>;
    /**
     * Array of the variables of benchmark cases.
     */
    readonly results: FlattedResult[];
    /**
     * Additional noteworthy information generated during the run of the suite.
     *
     * @see ProfilingContext.warn
     * @see ProfilingContext.note
     */
    readonly notes: ResolvedNote[];
    /**
     * The suite's baseline option.
     */
    readonly baseline?: ResultBaseline;
    private table;
    private keys;
    private weights;
    /**
     * Parsing the results of the benchmark suite runs to create Summary.
     *
     * The parameter is usually the results of a suite under its toolchains,
     * but there is also support for passing results of different suites to merge them,
     * in this case you need to avoid conflicts in analyzers and baselines.
     */
    constructor(suiteResults: ToolchainResult[]);
    private addResult;
    private addToVar;
    static getMetrics(item: FlattedResult): Metrics;
    /**
     * Sort results by variables, use multiple keys sort algorithm.
     * The more precedent key in `keys` have higher weight,
     * for each key, the priority is index of the value in `this.vars.get(key)`.
     *
     * @param keys Sort keys, must be all of `this.vars.keys()`.
     */
    sort(keys: string[]): void;
    private getIndex;
    private getWeight;
    /**
     * Grouping results by all variables except the key parameter.
     */
    split(key: string): Map<number, FlattedResult[]>;
    /**
     * Find the result that contains exactly the variables, non-variable properties are ignored.
     *
     * @return Corresponding result, or `undefined` if it does not exist.
     */
    find(variables: Record<string, string>): FlattedResult | undefined;
    /**
     * Lists the results of all the values of a variable when other variables have the specified values.
     *
     * @param constants Control variables.
     * @param variable Name of the changed variable.
     */
    findAll(constants: Record<string, string>, variable: string): (FlattedResult | undefined)[];
}
export {};
