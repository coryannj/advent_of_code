import { BUILTIN_VARS, RE_ANY, runFns, toDisplayName } from "./utils.js";
export class BenchCase {
    name;
    /**
     * The workload function, should be called with iteration hooks.
     *
     * Always treat the iteration hooks and `fn` as a whole,
     * calling `fn` separately will result in undefined behavior.
     *
     * @see BenchCase.invoke
     */
    fn;
    beforeHooks;
    afterHooks;
    /**
     * true if the case defined by `benchAsync`, false for `bench`.
     */
    isAsync;
    /**
     * A unique number within a suite execution.
     * It is used to associate some objects with this case.
     */
    id;
    constructor(scene, name, fn, isAsync) {
        this.name = name;
        this.fn = fn;
        this.isAsync = isAsync;
        this.beforeHooks = scene.beforeIterHooks;
        this.afterHooks = scene.afterIterHooks;
    }
    /**
     * Call the workload and each iteration hook once.
     *
     * The returned value is always awaited even if `isAsync` is false.
     */
    async invoke() {
        await runFns(this.beforeHooks);
        try {
            return await this.fn();
        }
        finally {
            await runFns(this.afterHooks);
        }
    }
    /**
     * Create an new benchmark case for the workload function,
     * and it has the same name & id with the original.
     *
     * `beforeHooks` and `afterHooks` can be added later.
     *
     * @param isAsync Indicates whether ESBench need to `await` for
     *                the return value of `fn` while measuring.
     * @param fn the new workload function.
     */
    derive(isAsync, fn) {
        const instance = Object.create(BenchCase.prototype);
        instance.name = this.name;
        instance.fn = fn;
        instance.isAsync = isAsync;
        instance.beforeHooks = [];
        instance.afterHooks = [];
        instance.id = this.id;
        return instance;
    }
}
export class Scene {
    teardownHooks = [];
    beforeIterHooks = [];
    afterIterHooks = [];
    cases = [];
    params;
    include;
    constructor(params, include = RE_ANY) {
        this.params = params;
        this.include = include;
    }
    /**
     * Register a callback to be called exactly once before each benchmark invocation.
     * It's not recommended to use this in microbenchmarks because it can spoil the results.
     */
    beforeIteration(fn) {
        this.beforeIterHooks.push(fn);
    }
    /**
     * Register a callback to be called exactly once after each invocation.
     * It's not recommended to use this in microbenchmarks because it can spoil the results.
     */
    afterIteration(fn) {
        this.afterIterHooks.push(fn);
    }
    /**
     * Teardown function to run after all case in the scene are executed.
     */
    teardown(fn) {
        this.teardownHooks.push(fn);
    }
    /**
     * Add a benchmark case to the scene, and consider an execution complete when `fn` returns.
     *
     * For asynchronous function, you may need to use `benchAsync` instead.
     *
     * @param name Name of the case
     * @param fn The workload function
     */
    bench(name, fn) {
        this.add(name, fn, false);
    }
    /**
     * Add a benchmark case to the scene. If `fn` returns a Promise, it will be awaited.
     *
     * For synchronized function `bench` should be used to avoid the overhead of `await`.
     *
     * @param name Name of the case
     * @param fn The workload function
     */
    benchAsync(name, fn) {
        this.add(name, fn, true);
    }
    /*
     * Don't use `isAsync = fn.constructor !== Function` because the fn can be
     * non-async and return a Promise.
     *
     * For example:
     * scene.bench("name", () => asyncFn(args));
     *
     * It can be fixed by adding `await` to the function, but it impacts performance.
     * Related benchmark: example/es/async-return-promise.js
     */
    add(name, fn, isAsync) {
        const { length } = name.trim();
        if (length === 0) {
            throw new Error("Case name cannot be blank.");
        }
        if (length !== name.length) {
            throw new Error("Case name cannot have leading or trailing spaces.");
        }
        if (this.cases.some(c => c.name === name)) {
            throw new Error(`Case "${name}" already exists.`);
        }
        if (this.include.test(name)) {
            this.cases.push(new BenchCase(this, name, fn, isAsync));
        }
    }
}
/**
 * Type helper to mark the object as an ESBench suite.
 * IDE plugins also require it to find benchmark cases.
 */
export const defineSuite = (suite) => suite;
function* getFromIter(values) {
    for (const value of values)
        yield [value, value];
}
function getFromObject(values) {
    return Object.entries(values);
}
export function resolveParams(params) {
    const nameEntries = Object.entries(params);
    const valueEntries = new Array(nameEntries.length);
    if (Object.getOwnPropertySymbols(params).length) {
        throw new Error("Only string keys are allowed in param");
    }
    for (let i = 0; i < nameEntries.length; i++) {
        const [key, valueDefs] = nameEntries[i];
        if (BUILTIN_VARS.includes(key)) {
            throw new Error(`'${key}' is a builtin variable`);
        }
        const names = new Set();
        const values = [];
        const iter = Symbol.iterator in valueDefs
            ? getFromIter(valueDefs)
            : getFromObject(valueDefs);
        for (const [name, value] of iter) {
            const display = toDisplayName(name);
            if (names.has(display)) {
                throw new Error(`Parameter display name conflict (${key}: ${display})`);
            }
            names.add(display);
            values.push(value);
        }
        nameEntries[i][1] = [...names];
        valueEntries[i] = [key, values];
        if (names.size === 0) {
            throw new Error(`Suite parameter "${key}" must have a value`);
        }
    }
    return [valueEntries, nameEntries];
}
export function normalizeSuite(input) {
    if (typeof input === "function") {
        return { params: [], paramNames: [], timing: {}, setup: input };
    }
    const [params, paramNames] = resolveParams(input.params ?? {});
    let timing;
    switch (input.timing) {
        case true:
        case undefined:
            timing = {};
            break;
        case false:
            timing = undefined;
            break;
        default:
            timing = input.timing;
    }
    return { ...input, params, paramNames, timing };
}
//# sourceMappingURL=suite.js.map