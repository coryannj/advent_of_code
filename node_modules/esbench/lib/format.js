import { dataSizeIEC, decimalPrefix, durationFmt, identity, separateThousand, } from "@kaciras/utilities/browser";
import { markdownTable } from "markdown-table";
const noColor = new Proxy(identity, { get: identity });
const formatRE = /^\{(\w+)(?:\.(\w+))?}/;
const unitConvertors = {
    number: decimalPrefix,
    duration: durationFmt,
    dataSize: dataSizeIEC,
};
class CommonUnitFormatter {
    convertor;
    unit;
    suffix;
    constructor(unit, suffix, convertor) {
        if (unit === undefined) {
            this.unit = convertor.units[0];
        }
        else {
            this.unit = unit;
        }
        this.suffix = suffix;
        this.convertor = convertor;
    }
    fixed(values) {
        const { convertor, unit, suffix } = this;
        const numbers = [];
        for (const value of values) {
            switch (typeof value) {
                case "string":
                    throw new TypeError(`Cannot apply number format to "${value}"`);
                case "number":
                    numbers.push(value);
            }
        }
        const fixed = convertor.homogeneous(numbers, unit);
        return new CommonUnitFixed(fixed, suffix);
    }
    format(value) {
        const { convertor, unit, suffix } = this;
        switch (typeof value) {
            case "string":
                throw new TypeError(`Cannot apply number format to "${value}"`);
            case "undefined":
                return "";
        }
        const string = convertor.formatDiv(value, unit);
        return separateThousand(string) + suffix;
    }
}
class CommonUnitFixed {
    convertor;
    suffix;
    constructor(convertor, suffix) {
        this.convertor = convertor;
        this.suffix = suffix;
    }
    get scale() {
        return this.convertor.scale;
    }
    get unit() {
        return this.convertor.unit + this.suffix;
    }
    format(value) {
        switch (typeof value) {
            case "string":
                throw new TypeError(`Cannot apply number format to "${value}"`);
            case "undefined":
                return "";
        }
        const string = this.convertor.format(value);
        return separateThousand(string) + this.suffix;
    }
}
const stringFormatter = {
    scale: 1,
    unit: "",
    fixed: () => stringFormatter,
    format: value => value ? value.toString() : "",
};
export function createFormatter(template) {
    if (!template) {
        return stringFormatter;
    }
    const match = formatRE.exec(template);
    if (!match) {
        throw new Error(`Invalid metric format: ${template}`);
    }
    const [{ length }, type, rawUnit] = match;
    const convertor = unitConvertors[type];
    if (!convertor) {
        throw new Error(`Metric type: "${type}" does not have convertor`);
    }
    const suffix = template.slice(length);
    return new CommonUnitFormatter(rawUnit, suffix, convertor);
}
function toMarkdown(stringLength) {
    return markdownTable(this, { stringLength, align: "r" });
}
export default function format(input, options = {}) {
    const { formats, cells, colors, groupEnds } = input;
    const { flexUnit = false, stainer = noColor } = options;
    const table = [[]];
    function applyStyle(value, r, c) {
        const x = colors[r][c];
        return x ? stainer[x](value) : stainer(value);
    }
    // Apply colors to the header.
    for (let i = 0; i < formats.length; i++) {
        const v = cells[0][i];
        table[0].push(applyStyle(v, 0, i));
    }
    // The empty row should have same length with the table.
    const separator = new Array(formats.length);
    let offset = 1;
    for (const e of groupEnds) {
        const copy = cells.slice(offset, e).map(r => r.slice());
        for (let i = 0; i < formats.length; i++) {
            let formatter = createFormatter(formats[i]);
            if (!flexUnit && formatter.fixed) {
                formatter = formatter.fixed(copy.map(r => r[i]));
            }
            for (let j = 0; j < copy.length; j++) {
                const v = formatter.format(copy[j][i]);
                copy[j][i] = applyStyle(v, offset + j, i);
            }
        }
        offset = e;
        table.push(...copy, separator);
    }
    table.pop();
    table.toMarkdown = toMarkdown;
    return table;
}
//# sourceMappingURL=format.js.map