import { cartesianObject } from "@kaciras/utilities/browser";
import { groupBy, indexOf } from "./utils.js";
const kMetrics = Symbol("metrics");
const kIndex = Symbol("index");
export class Summary {
    /**
     * All variable names and each of their possible values.
     */
    vars = new Map();
    /**
     * Descriptions of metrics.
     *
     * @see ProfilingContext.meta
     */
    meta = new Map();
    /**
     * Array of the variables of benchmark cases.
     */
    results = [];
    /**
     * Additional noteworthy information generated during the run of the suite.
     *
     * @see ProfilingContext.warn
     * @see ProfilingContext.note
     */
    notes = [];
    /**
     * The suite's baseline option.
     */
    baseline;
    table;
    keys;
    weights = [];
    /**
     * Parsing the results of the benchmark suite runs to create Summary.
     *
     * The parameter is usually the results of a suite under its toolchains,
     * but there is also support for passing results of different suites to merge them,
     * in this case you need to avoid conflicts in analyzers and baselines.
     */
    constructor(suiteResults) {
        // Ensure the Name is the first entry.
        this.vars.set("Name", new Set());
        for (const result of suiteResults) {
            this.addResult(result);
            this.baseline = result.baseline;
        }
        const [name, ...rest] = Array.from(this.vars.keys());
        this.sort([...rest, name]);
    }
    addResult(result) {
        const { executor, builder, paramDef, scenes, notes, tags = {} } = result;
        const offset = this.results.length;
        const iter = cartesianObject(paramDef)[Symbol.iterator]();
        if (executor) {
            this.addToVar("Executor", executor);
        }
        if (builder) {
            this.addToVar("Builder", builder);
        }
        for (const [key, values] of paramDef) {
            this.addToVar(key, ...values);
        }
        for (const [key, value] of Object.entries(tags)) {
            this.addToVar(key, value);
        }
        for (const [k, v] of Object.entries(result.meta)) {
            this.meta.set(k, v);
        }
        for (const scene of scenes) {
            const params = iter.next().value;
            for (const [name, metrics] of Object.entries(scene)) {
                /*
                 * Access a variable should always check it is in `vars` before, if exists
                 * in `vars` but the value is undefined, that means the result in broken.
                 */
                const flatted = {
                    Name: name,
                    Executor: executor,
                    Builder: builder,
                    ...params,
                    ...tags,
                    [kMetrics]: metrics,
                };
                this.results.push(flatted);
                this.addToVar("Name", name);
            }
        }
        for (const { type, text, caseId } of notes) {
            const resolved = { type, text };
            this.notes.push(resolved);
            if (caseId !== undefined) {
                resolved.case = this.results[offset + caseId];
            }
        }
    }
    addToVar(name, ...values) {
        let list = this.vars.get(name);
        if (!list) {
            this.vars.set(name, list = new Set());
        }
        for (const value of values)
            list.add(value);
    }
    static getMetrics(item) {
        return item[kMetrics];
    }
    /**
     * Sort results by variables, use multiple keys sort algorithm.
     * The more precedent key in `keys` have higher weight,
     * for each key, the priority is index of the value in `this.vars.get(key)`.
     *
     * @param keys Sort keys, must be all of `this.vars.keys()`.
     */
    sort(keys) {
        const { results, vars, weights } = this;
        if (new Set(keys).size !== vars.size) {
            throw new Error("Keys must be all variable names");
        }
        weights.length = keys.length;
        let weight = 1;
        for (let i = weights.length - 1; i >= 0; i--) {
            const k = keys[i];
            const values = vars.get(k);
            if (!values) {
                throw new Error(`${k} is not in variables`);
            }
            weights[i] = weight;
            weight *= values.size;
        }
        this.table = new Array(weight);
        this.keys = keys;
        for (const item of results) {
            const index = this.getIndex(item);
            item[kIndex] = index;
            this.table[index] = item;
        }
        let index = 0;
        for (const maybeItem of this.table) {
            if (maybeItem)
                results[index++] = maybeItem;
        }
    }
    getIndex(props) {
        const { keys, weights, vars } = this;
        let cpIndex = 0;
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            const v = props[k];
            // Already checked in `sort`.
            const s = vars.get(k);
            const varIndex = indexOf(s, v);
            if (varIndex === -1) {
                return NaN;
            }
            cpIndex += weights[i] * varIndex;
        }
        return cpIndex;
    }
    getWeight(key) {
        const i = this.keys.indexOf(key);
        if (i !== -1) {
            return this.weights[i];
        }
        throw new Error(`${key} is not in variables`);
    }
    /**
     * Grouping results by all variables except the key parameter.
     */
    split(key) {
        const values = this.vars.get(key);
        const w = this.getWeight(key);
        return groupBy(this.results, item => item[kIndex] - w * indexOf(values, item[key]));
    }
    /**
     * Find the result that contains exactly the variables, non-variable properties are ignored.
     *
     * @return Corresponding result, or `undefined` if it does not exist.
     */
    find(variables) {
        return this.table[this.getIndex(variables)];
    }
    /**
     * Lists the results of all the values of a variable when other variables have the specified values.
     *
     * @param constants Control variables.
     * @param variable Name of the changed variable.
     */
    findAll(constants, variable) {
        const values = this.vars.get(variable);
        if (!values) {
            throw new Error(`${variable} is not in variables`);
        }
        const w = this.getWeight(variable);
        const c = w * indexOf(values, constants[variable]);
        const base = this.getIndex(constants) - c;
        return Array.from(values, (_, i) => this.table[base + w * i]);
    }
}
//# sourceMappingURL=summary.js.map