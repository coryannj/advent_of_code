import { Awaitable } from "@kaciras/utilities/node";
import { HostContext } from "./context.js";
import { Channel, ClientMessage } from "../connect.js";
export interface Builder {
    /**
     * Suggest a name for the builder, it will be used if no name specified from config.
     */
    name: string;
    /**
     * Transform the files needed for the benchmark.
     * The path of the generated entry must be [outDir]/index.js
     *
     * @param outDir The directory in which all generated chunks should be placed.
     * @param files Suite file paths relative to cwd.
     */
    build(outDir: string, files: string[]): Awaitable<void>;
}
/**
 * The entry file that build output needs to export a function that match the signature.
 *
 * This function needs to call `runAndSend` and provide the import module function.
 */
export type EntryExport = (postMessage: Channel, files: string[], pattern?: string) => Promise<void>;
export interface SuiteTask {
    /**
     * Output directory of the build, can be used to resolve imports.
     */
    root: string;
    /**
     * Path (relative to cwd) of the suite file to run.
     */
    file: string;
    /**
     * Run benchmark with names matching the Regex pattern.
     */
    pattern?: string;
    /**
     * Make execution fail, useful for executions that can't wait to finish.
     */
    reject(error: Error): void;
    /**
     * Executor should forward messages from `EntryExport` to this function.
     */
    dispatch(message: ClientMessage): void;
}
export interface Executor {
    /**
     * Suggest a name for the executor, it will be used if no name specified from config.
     */
    name: string;
    /**
     * Called once before the executor starts executing suites.
     */
    start?(ctx: HostContext): Awaitable<unknown>;
    /**
     * Called only once after all suites execution finished, or an error occurred during the execution.
     *
     * If an implementation uses exclusive global resources, it should return a Promise
     * for asynchronous operations so that ESBench can wait for resources to be released.
     */
    close?(ctx: HostContext): Awaitable<unknown>;
    /**
     * Run a suite of a builder output.
     *
     * An execution will complete when `ESBenchResult` is passed to `task.dispatch`
     * and the returned Promise is satisfied (if present).
     */
    execute(task: SuiteTask): Awaitable<unknown>;
}
/**
 * You can assign a name for a tool (builder or executor). Each tool can only have one name.
 *
 * @example
 * export default defineConfig({
 *   toolchains: [{
 *     builders: [
 *       new ViteBuilder({ build: { minify: false } }),
 *       {
 *           name: "Vite Minified"
 *           use: new ViteBuilder({ build: { lib: false, minify: true } }),
 *       }
 *     ]
 *   }]
 * });
 */
export type Nameable<T> = T | {
    name: string;
    use: T;
};
export interface ToolChainItem {
    exclude?: string[];
    include: string[];
    builders: Array<Nameable<Builder>>;
    executors: Array<Nameable<Executor>>;
}
export interface BuildResult {
    name: string;
    root: string;
    files: string[];
}
export interface Job {
    name: string;
    executor: Executor;
    builds: BuildResult[];
}
export declare function toSpecifier(path: string, parent: string): string;
export default class JobGenerator {
    private readonly eSet;
    private readonly bSet;
    private readonly e2b;
    private readonly context;
    constructor(context: HostContext);
    /**
     * Convenience functions for generating jobs using the context's toolchains.
     */
    static generate(context: HostContext): Promise<Job[]>;
    add(item: ToolChainItem, index?: number): void;
    build(): Promise<void>;
    getJobs(): Generator<Job, void, unknown>;
    private scanSuiteFiles;
    private normalize;
}
