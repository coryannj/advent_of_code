import { cwd } from "node:process";
import { basename, join, relative } from "node:path";
import { mkdtempSync } from "node:fs";
import { UniqueMultiMap } from "@kaciras/utilities/node";
import glob from "fast-glob";
export function toSpecifier(path, parent) {
    path = relative(parent, path);
    path = path.replaceAll("\\", "/");
    return /\.\.?\//.test(path) ? path : "./" + path;
}
export default class JobGenerator {
    eSet = new Map();
    bSet = new Map();
    e2b = new UniqueMultiMap();
    context;
    constructor(context) {
        this.context = context;
    }
    /**
     * Convenience functions for generating jobs using the context's toolchains.
     */
    static async generate(context) {
        const generator = new JobGenerator(context);
        const { toolchains } = context.config;
        for (let i = 0; i < toolchains.length; i++) {
            generator.add(toolchains[i], i);
        }
        await generator.build();
        return Array.from(generator.getJobs());
    }
    add(item, index = -1) {
        const { builder: builderRE, executor: executorRE } = this.context.filter;
        const files = this.scanSuiteFiles(item);
        if (files.length === 0) {
            return; // No file matches, skip this item.
        }
        const eEntries = item.executors
            .filter(executor => executorRE.test(executor.name))
            .map(this.normalize.bind(this, index, this.eSet));
        for (const executor of eEntries) {
            files.forEach(Set.prototype.add, executor.fileSet);
        }
        for (let i = 0; i < item.builders.length; i++) {
            const builder = item.builders[i];
            if (!builderRE.test(builder.name)) {
                continue;
            }
            const builderUsed = this.normalize(index, this.bSet, builder, i);
            this.e2b.distribute(eEntries, builderUsed);
            files.forEach(Set.prototype.add, builderUsed.fileSet);
        }
    }
    async build() {
        const { context, bSet } = this;
        const { config: { tempDir } } = context;
        context.info(`Building suites with ${bSet.size} builders [tempDir=${tempDir}]...`);
        for (const entry of bSet.values()) {
            const root = mkdtempSync(join(tempDir, "build-"));
            const { name, fileSet, tool } = entry;
            const files = Array.from(fileSet);
            context.debug(`├─ ${name} [${basename(root)}]: ${files.length} suites.`);
            await tool.build(root, files);
            entry.output = { name, root, files };
        }
    }
    *getJobs() {
        for (const [entry, builders] of this.e2b) {
            const { tool: executor, name, fileSet } = entry;
            const builds = [];
            // Only add builds that have files match the executor's glob pattern.
            for (const { output } of builders) {
                const files = output.files.filter(f => fileSet.has(f));
                if (files.length) {
                    builds.push({ ...output, files });
                }
            }
            // Executors without files to execute will be skipped.
            if (builds.length) {
                yield { name, executor, builds };
            }
        }
    }
    scanSuiteFiles({ exclude = [], include }) {
        const { shared, file } = this.context.filter;
        const workingDir = cwd();
        // Ensure glob patterns is relative and starts with ./ or ../
        include = include.map(i => toSpecifier(i, workingDir));
        exclude = exclude.map(i => toSpecifier(i, workingDir));
        const part = file ? relative(cwd(), file).replaceAll("\\", "/") : "";
        return glob.sync(include, { ignore: exclude })
            .filter(i => i.includes(part) && shared.roll());
    }
    /*
     * Since TypeScript does not yet support generic inference of `Function.bind`,
     * we use `Map<any, any>` for now.
     *
     * https://github.com/microsoft/TypeScript/issues/54707
     */
    normalize(i, set, nameable, j) {
        const { name } = nameable;
        const [keyMethod, type] = set === this.bSet
            ? ["build", "builders"]
            : ["execute", "executors"];
        if (/^\s*$/.test(name)) {
            const loc = getLocation(type, i, j);
            throw new Error("Tool name must be a non-blank string\n└─ " + loc);
        }
        // Assume the name wrapper does not have any extra property.
        const tool = keyMethod in nameable ? nameable : nameable.use;
        for (const [t, e] of set) {
            if (t !== tool && e.name === name) {
                throw conflict(type, "Each tool must have a unique name: " + name, i, j, e);
            }
        }
        let exist = set.get(tool);
        if (!exist) {
            set.set(tool, exist = {
                name,
                tool,
                chainIndex: i,
                listIndex: j,
                fileSet: new Set(),
            });
        }
        if (exist.name === name) {
            return exist;
        }
        else {
            throw conflict(type, `A tool can only have one name (${exist.name} vs ${name})`, i, j, exist);
        }
    }
}
function getLocation(type, i, j) {
    return `toolchains[${i}].${type}[${j}]`;
}
function conflict(type, message, i, j, prev) {
    message += "\n├─ ";
    message += getLocation(type, prev.chainIndex, prev.listIndex);
    return new Error(message + "\n└─ " + getLocation(type, i, j));
}
//# sourceMappingURL=toolchain.js.map