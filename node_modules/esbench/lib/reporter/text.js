import { createWriteStream } from "node:fs";
import { stdout } from "node:process";
import { once } from "node:events";
import stringLength from "string-width";
import chalk, { Chalk } from "chalk";
import { SummaryTable } from "../table.js";
function print(result, previous, options, out) {
    const { stainer = chalk } = options;
    const entries = Object.entries(result);
    out.write(stainer.blueBright(`Text reporter: Format benchmark results of ${entries.length} suites:`));
    for (const [name, toolchains] of entries) {
        const diff = previous[name];
        const table = SummaryTable.from(toolchains, diff, options);
        out.write(stainer.greenBright("\nSuite: "));
        out.write(name);
        out.write("\n");
        out.write(table.format(options).toMarkdown(stringLength));
        out.write("\n");
        if (table.hints.length > 0) {
            out.write(stainer.cyan("Hints:\n"));
            for (const note of table.hints) {
                out.write(stainer.cyan(note));
                out.write("\n");
            }
        }
        if (table.warnings.length > 0) {
            out.write(stainer.yellowBright("Warnings:\n"));
            for (const note of table.warnings) {
                out.write(stainer.yellowBright(note));
                out.write("\n");
            }
        }
        out.write("\n");
    }
}
/**
 * Format the results into text and output to various streams.
 */
export default function (options = {}) {
    const { file, console = true } = options;
    return async (result, context) => {
        if (console) {
            options.stainer = chalk;
            print(result, context.previous, options, stdout);
        }
        if (file) {
            const stream = createWriteStream(file);
            options.stainer = new Chalk({ level: 0 });
            print(result, context.previous, options, stream);
            await once(stream.end(), "finish");
        }
    };
}
//# sourceMappingURL=text.js.map