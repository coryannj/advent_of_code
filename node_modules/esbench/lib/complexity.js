import { mean } from "simple-statistics";
import { minimalLeastSquare } from "./math.js";
const defaultCurves = {
    "O(1)": _ => 1,
    "O(N)": n => n,
    "O(logN)": n => Math.log2(n),
    "O(NlogN)": n => n * Math.log2(n),
    "O(N^2)": n => n * n,
    "O(N^3)": n => n ** 3,
};
export default class ComplexityProfiler {
    metric;
    param;
    curves;
    index = NaN;
    weights;
    constructor(options) {
        this.metric = options.metric;
        this.param = options.param;
        this.curves = options.curves ?? defaultCurves;
    }
    onStart(ctx) {
        ctx.defineMetric({ key: "complexity" });
        const { params } = ctx.suite;
        this.weights = new Array(params.length);
        let weight = 1;
        for (let i = params.length - 1; i >= 0; i--) {
            const [k, values] = params[i];
            if (k === this.param) {
                this.index = i;
            }
            this.weights[i] = weight;
            weight *= values.length;
        }
        if (!params[this.index][1].every(Number.isFinite)) {
            throw new Error(`Param ${this.param} must be finite numbers`);
        }
    }
    onFinish(ctx) {
        const { index, weights, metric, curves } = this;
        const params = ctx.suite.params;
        const input = params[index][1];
        arrange(0, 0);
        function arrange(depth, k) {
            if (depth === index) {
                return arrange(depth + 1, k);
            }
            if (depth === weights.length) {
                return calculate(k);
            }
            for (let i = 0; i < params[depth][1].length; i++) {
                arrange(depth + 1, k + weights[depth] * i);
            }
        }
        function calculate(k) {
            const metricsMap = new Map();
            const timeMap = new Map();
            // Group metric values by cases.
            for (let i = 0; i < input.length; i++) {
                const scene = ctx.scenes[k + i * weights[index]];
                for (const [name, metrics] of Object.entries(scene)) {
                    let samples = timeMap.get(name);
                    let metricsList = metricsMap.get(name);
                    if (!samples) {
                        metricsMap.set(name, metricsList = []);
                        timeMap.set(name, samples = new Array(input.length));
                    }
                    metricsList.push(metrics);
                    const value = metrics[metric];
                    if (typeof value === "number") {
                        samples[i] = value;
                    }
                    else if (Array.isArray(value)) {
                        samples[i] = mean(value);
                    }
                }
            }
            for (const [name, values] of timeMap) {
                const inputF = [];
                const valuesF = [];
                // Filter out `undefined` of absent cases.
                for (let i = 0; i < values.length; i++) {
                    if (Number.isFinite(values[i])) {
                        inputF.push(input[i]);
                        valuesF.push(values[i]);
                    }
                }
                if (valuesF.length < 2) {
                    continue; // Minimum require 2 points.
                }
                let bestFit = Number.MAX_VALUE;
                let complexity = "O(1)";
                for (const [type, f] of Object.entries(curves)) {
                    const rms = minimalLeastSquare(inputF, valuesF, f);
                    if (rms < bestFit) {
                        bestFit = rms;
                        complexity = type;
                    }
                }
                for (const metrics of metricsMap.get(name)) {
                    metrics.complexity = complexity;
                }
            }
        }
    }
}
//# sourceMappingURL=complexity.js.map