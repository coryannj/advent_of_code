import { alwaysTrue, noop } from "@kaciras/utilities/browser";
import { attrx } from "./utils.js";
const NONE = Symbol();
class PreValidateProfiler {
    isEqual;
    check;
    nameA;
    valueA = NONE;
    scene;
    constructor(check, isEqual) {
        this.check = check;
        this.isEqual = isEqual;
    }
    onScene(_, scene) {
        this.scene = scene;
        this.valueA = NONE;
    }
    async onCase(_, case_) {
        const { nameA, valueA, scene, isEqual, check } = this;
        const { name } = case_;
        const returnValue = await case_.invoke();
        check(returnValue, scene.params);
        if (valueA === NONE) {
            this.valueA = returnValue;
            this.nameA = name;
        }
        else if (!isEqual(valueA, returnValue)) {
            throw new Error(`"${nameA}" and "${name}" returns different value`);
        }
    }
}
export class ExecutionValidator {
    isEqual;
    check;
    constructor({ equality, check }) {
        this.check = check ?? noop;
        if (equality === true) {
            this.isEqual = (a, b) => a === b;
        }
        else if (equality) {
            this.isEqual = equality;
        }
        else {
            this.isEqual = alwaysTrue;
        }
    }
    /**
     * To catch errors as early as possible, we start a new workflow for the validator.
     */
    async onStart(ctx) {
        const details = [
            "Execution",
            this.isEqual !== alwaysTrue && "Equality",
            this.check !== noop && "ReturnValue",
        ];
        await ctx.info(`Validating benchmarks${attrx(details)}...`);
        const validator = new PreValidateProfiler(this.check, this.isEqual);
        await ctx.newWorkflow([validator]).run();
    }
}
//# sourceMappingURL=validate.js.map