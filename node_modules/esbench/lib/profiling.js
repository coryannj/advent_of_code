import { cartesianObject } from "@kaciras/utilities/browser";
import { Scene } from "./suite.js";
import { RE_ANY, runFns } from "./utils.js";
const consoleLogHandler = (message = "", level) => console[level](message);
export var MetricAnalysis;
(function (MetricAnalysis) {
    /**
     * There is no analyze performed to the metric. This is the default value.
     */
    MetricAnalysis[MetricAnalysis["None"] = 0] = "None";
    /**
     * Reporters should show diff & ratio with another result if present for the metric.
     * The metric value must be a number or an array of number with at least 1 element.
     */
    MetricAnalysis[MetricAnalysis["Compare"] = 1] = "Compare";
    /**
     * Reporters should display statistical indicators (stdDev, percentiles...) for the metric.
     * The metric value must be an array of number with at least 1 element.
     *
     * Setting this value will also apply `MetricAnalysis.Compare`.
     */
    MetricAnalysis[MetricAnalysis["Statistics"] = 2] = "Statistics";
})(MetricAnalysis || (MetricAnalysis = {}));
export class ProfilingContext {
    /**
     * Result for each case in each scene.
     */
    scenes = [];
    /**
     * Notes collected from the profiling.
     *
     * @see ProfilingContext.note
     */
    notes = [];
    /**
     * Descriptions of metrics.
     *
     * @see ProfilingContext.defineMetric
     */
    meta = {};
    suite;
    profilers;
    pattern;
    logHandler;
    hasRun = false;
    caseIndex = 0;
    constructor(suite, profilers, options) {
        this.suite = suite;
        this.profilers = profilers;
        this.pattern = options.pattern ?? RE_ANY;
        this.logHandler = options.log ?? consoleLogHandler;
    }
    /**
     * Profiler should add description for each metric that need to be reported.
     *
     * Values in the case metrics without descriptions will not be shown in the report,
     * but they will still be serialized.
     *
     * @param description The description of the metric.
     */
    defineMetric(description) {
        this.meta[description.key] = description;
    }
    /**
     * Using this method will generate warnings, which are logs with log level "warn".
     */
    warn(message) {
        return this.logHandler(message, "warn");
    }
    /**
     * Generate an "info" log. As these logs are displayed by default, use them for information
     * that is not a warning but makes sense to display to all users.
     */
    info(message) {
        return this.logHandler(message, "info");
    }
    /**
     * Add a note to result, it will print a log and displayed in the report.
     *
     * The different between notes and logs is that
     * notes are only relevant to the result, while logs can record anything.
     *
     * @param type Type of the note, "info" or "warn".
     * @param text The message of this note.
     * @param case_ The case associated with this note.
     */
    note(type, text, case_) {
        this.notes.push({ type, text, caseId: case_?.id });
        return this.logHandler(text, type);
    }
    /**
     * Create a new ProfilingContext for the same suite.
     *
     * Profilers & options are not inherited.
     */
    newWorkflow(profilers, options = {}) {
        return new ProfilingContext(this.suite, profilers, options);
    }
    /**
     * Run the profiling, the result is saved at `scenes`, `notes` and `meta` properties.
     *
     * A ProfilingContext instance can only be run once.
     */
    async run() {
        const { hasRun, suite: { params } } = this;
        if (hasRun) {
            throw new Error("A ProfilingContext can only be run once.");
        }
        this.hasRun = true;
        await this.runHooks("onStart");
        for (const comb of cartesianObject(params)) {
            await this.runScene(comb);
        }
        return this.runHooks("onFinish");
    }
    async runScene(params) {
        const scene = new Scene(params, this.pattern);
        await this.suite.setup(scene);
        try {
            await this.runHooks("onScene", scene);
            const results = {};
            this.scenes.push(results);
            for (const case_ of scene.cases) {
                case_.id = this.caseIndex++;
                const metrics = {};
                await this.runHooks("onCase", case_, metrics);
                results[case_.name] = metrics;
            }
        }
        finally {
            await runFns(scene.teardownHooks);
        }
    }
    async runHooks(name, ...args) {
        for (const profiler of this.profilers) {
            // @ts-expect-error Is it a TypeScript bug?
            await profiler[name]?.(this, ...args);
        }
    }
}
//# sourceMappingURL=profiling.js.map