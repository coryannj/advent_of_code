import { deserializeError, serializeError } from "serialize-error";
import { runSuite } from "./runner.js";
export function getMessageType(message) {
    if ("level" in message) {
        return "log";
    }
    return "e" in message ? "error" : "result";
}
/**
 * Import and run suites, then send the results over the channel.
 *
 * @param postMessage Function used to transfer the results to the host.
 * @param importer Function to import a suite, normally provided by builder.
 * @param file Path of the suite file to run.
 * @param pattern A Regexp string for filter benchmark cases by name.
 */
export async function runAndSend(postMessage, importer, file, pattern) {
    const option = {
        log: (log, level) => postMessage({ level, log }),
        pattern: pattern ? new RegExp(pattern) : undefined,
    };
    try {
        const { default: suite } = await importer(file);
        if (file.startsWith("./")) {
            file = file.slice(2);
        }
        postMessage({ level: "info", log: `\nSuite: ${file}` });
        const result = await runSuite(suite, option);
        result.name = file;
        return postMessage(result);
    }
    catch (e) {
        return postMessage({ e: serializeError(e) });
    }
}
/**
 * A helper to deal with runner messages, forward messages to `dispatch`
 * and then you can wait for the promise to finish runs.
 *
 * @param onLog function to handle log messages.
 */
export function messageResolver(onLog) {
    let resolve;
    let reject;
    const promise = new Promise((s, j) => {
        resolve = s;
        reject = j;
    });
    function dispatch(message) {
        if ("scenes" in message) {
            resolve(message);
        }
        else if ("e" in message) {
            reject(deserializeError(message.e));
        }
        else {
            onLog(message.log, message.level);
        }
    }
    return { promise, resolve, reject, dispatch };
}
//# sourceMappingURL=connect.js.map