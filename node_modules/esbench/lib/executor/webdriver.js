import { join } from "node:path";
import * as WebDriver from "webdriverio";
import { createPathMapper, transformer } from "./transform.js";
import { blankPageResponse } from "./playwright.js";
export class WebdriverExecutor {
    resolveAsset;
    type;
    options;
    context;
    constructor(type, options) {
        this.type = type;
        this.options = options;
        this.resolveAsset = createPathMapper(options?.assets);
    }
    get name() {
        return this.type.name();
    }
    async start() {
        const browser = await WebDriver.remote();
        this.context = await browser.newContext();
    }
    async close() {
        await this.context.close();
        await this.context.browser()?.close();
    }
    execute(options) {
        return this.executeInPage(options, baseURL);
    }
    async serve(root, path, route) {
        if (path === "/") {
            return route.fulfill(blankPageResponse);
        }
        try {
            const resolved = transformer.parse(root, path);
            if (!resolved) {
                // Non-import request or resolving disabled.
                path = this.resolveAsset(path) ?? join(root, path);
                return await route.fulfill({ path });
            }
            const body = await transformer.load(resolved);
            if (body) {
                // Transformed JS/TS module module.
                return route.fulfill({ body, contentType: "text/javascript" });
            }
            // No need to transform, send the file.
            return await route.fulfill({ path: resolved });
        }
        catch (e) {
            return route.fulfill({ status: 404, body: e.message });
        }
    }
    async executeInPage(task, url) {
        const { file, pattern, root, dispatch } = task;
        const [origin] = /^[^:/?#]+:(\/\/)?[^/?#]+/.exec(url);
        const page = await this.context.newPage();
        await page.exposeFunction("_ESBenchPost", (message) => {
            if ("e" in message) {
                transformer.fixStack(message.e, origin, root);
            }
            dispatch(message);
        });
        await this.context.route(origin + "/**", (route, request) => {
            const path = request.url().slice(origin.length);
            return this.serve(root, decodeURIComponent(path), route);
        });
        await page.goto(url);
        await page.evaluate(client, { file, pattern });
        await this.context.unrouteAll();
        await Promise.all(this.context.pages().map(p => p.close()));
    }
}
//# sourceMappingURL=webdriver.js.map