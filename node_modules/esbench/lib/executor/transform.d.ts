import { Awaitable } from "@kaciras/utilities/node";
export type MapPath = (path: string) => string | void;
export declare function createPathMapper(map?: Record<string, string>): MapPath;
interface TransformAdapter {
    compileTS(code: string, filename: string): Awaitable<string>;
    /**
     * Provides a module-relative resolution function scoped to each module.
     *
     * Unlike Vite, if an import in the module fails to resolve, the module can still be loaded.
     * ESBench always throw an error when reading a file that doesn't exist, not when resolving it.
     * This allows the user to write the suite more flexibility and catch related errors.
     *
     * @param specifier The module specifier to resolve relative to `parent`.
     * @param parent The absolute parent module URL to resolve from.
     * @return A URL string for the resolved module, or undefined if the resolve failed.
     */
    resolve(specifier: string, parent: string): string | undefined;
}
/**
 * ESBench's builtin module transformer, used for processing files to make them
 * executable in browser, it performs:
 *
 * - Compile TS code to JS code.
 * - Resolve file imports to absolute path.
 *
 * This transformer should work with builders.
 *
 * @example
 * try {
 *     const parsed = transformer.parse(root, path);
 *     if (!parsed) {
 *         // Non-import request or resolving disabled.
 *         return sendFile(join(root, path));
 *     }
 *     const body = await transformer.load(parsed);
 *     if (body) {
 *         // Transformed JS module.
 *         const headers = { "Content-Type": "text/javascript" };
 *         return new Response(body, { headers });
 *     } else {
 *         // No transform needed, just send the file.
 *         return sendFile(parsed);
 *     }
 * } catch (e) {
 *     // Resolve failed, or cannot read the file.
 *     return new Response(e.message, { status: 404 });
 * }
 *
 * @see https://esbench.vercel.app/guide/toolchains#built-in-transformer
 */
export declare const transformer: {
    adapter: TransformAdapter | null;
    /**
     * Get the file path of the import, or undefined if resolving is
     * disabled or the request is not created by import statement.
     *
     * If a module specifier is invalid, it will be converted to
     * `/@unresolvable?s=<specifier>&p=<importer>`, parsing it will throw an error.
     *
     * @param root The root folder of the page.
     * @param path The pathname of the request.
     */
    parse(root: string, path: string): string | undefined;
    /**
     * Read the file, and perform necessary transformation if possible.
     *
     * If the file does not exist, it will throw an Error with the code "ENOENT".
     *
     * @param path Path of the file.
     * @return Transformed data, or undefined if the file does not need to be transformed.
     */
    load(path: string): Promise<string | undefined>;
    transformImports(code: string, filename: string): string;
    /**
     * Convert stack of the error to Node format, and resolve locations to files.
     *
     * @param error The Error-like object
     * @param origin The origin of path that error thrown, no tail slash.
     * @param root Path of the site root directory.
     */
    fixStack(error: any, origin: string, root: string): void;
};
export {};
