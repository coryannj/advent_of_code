export { AESHelper, AsyncFunction, Composite, FetchClient, FetchClientError, LRUCache, MultiEventEmitter, MultiMap, NeverAbort, rpc as RPC, ResponseFacade, SingleEventEmitter, UniqueMultiMap, UnitConvertor, alwaysFalse, alwaysTrue, asyncNoop, base64url, blobToBase64URL, buildCLI, cartesianArray, cartesianObject, compositor, createInstance, dataSizeIEC, dataSizeSI, decimalPrefix, durationFmt, ellipsis, escapeHTML, fetchFile, firstItem, getCached, identity, noop, pathPrefix, pathSuffix, pubSub2ReqRes, separateThousand, sha256, silencePromise, silentCall, sleep, splitCLI, svgToUrl, transformBuffer, unescapeHTML, uniqueId } from './LRUCache.js';

function isPointerInside(event, el) {
    el ??= event.currentTarget;
    const { clientX, clientY } = event;
    const rect = el.getBoundingClientRect();
    return clientY > rect.top && clientY < rect.bottom && clientX > rect.left && clientX < rect.right;
}
function swapElements(nodeA, nodeB) {
    const parentB = nodeB.parentNode;
    const nextB = nodeB.nextSibling;
    if (nextB === nodeA) {
        return nodeB.before(nodeA);
    }
    nodeA.before(nodeB);
    if (nextB) {
        nextB.before(nodeA);
    } else {
        parentB.append(nodeA);
    }
}
function nthInChildren(el, from) {
    return Array.prototype.indexOf.call(el.parentNode.children, el, from);
}
function dragSortContext(swap = false) {
    let dragging = null;
    function dragstart(event) {
        dragging = event.currentTarget;
        dragging.removeEventListener("dragenter", dragenter);
    }
    function dragend() {
        dragging.isDragging = false;
        dragging.addEventListener("dragenter", dragenter);
        dragging = null;
    }
    function dragenter({ currentTarget }) {
        if (!dragging) {
            return;
        }
        dragging.isDragging = true;
        if (swap) {
            swapElements(dragging, currentTarget);
        } else {
            const i = nthInChildren(currentTarget);
            const j = nthInChildren(dragging, i);
            if (j === -1) {
                currentTarget.after(dragging);
            } else {
                currentTarget.before(dragging);
            }
        }
    }
    return {
        register (element) {
            element.addEventListener("dragstart", dragstart);
            element.addEventListener("dragend", dragend);
            element.addEventListener("dragenter", dragenter);
        },
        unregister (element) {
            element.removeEventListener("dragstart", dragstart);
            element.removeEventListener("dragend", dragend);
            element.removeEventListener("dragenter", dragenter);
        }
    };
}

function saveFile(blob, name) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name ?? blob.name;
    try {
        a.click();
    } finally{
        URL.revokeObjectURL(a.href);
    }
}
function selectFile(accept, multiple = false, directory = false) {
    const input = document.createElement("input");
    if (directory) {
        input.webkitdirectory = true;
    }
    input.type = "file";
    input.accept = accept;
    input.multiple = multiple;
    input.click();
    return new Promise((resolve, reject)=>{
        input.onerror = reject;
        input.onchange = ()=>resolve(input.files);
    });
}
function dragHandler(onMove) {
    return function(initEvent) {
        if (initEvent.button !== 0) {
            return;
        }
        initEvent.preventDefault();
        function handleMove(event) {
            onMove(event, initEvent);
        }
        function handleEnd(event) {
            event.preventDefault();
            document.removeEventListener("pointerup", handleEnd);
            document.removeEventListener("pointermove", handleMove);
        }
        document.addEventListener("pointerup", handleEnd);
        document.addEventListener("pointermove", handleMove);
    };
}

export { dragHandler, dragSortContext, isPointerInside, nthInChildren, saveFile, selectFile, swapElements };
