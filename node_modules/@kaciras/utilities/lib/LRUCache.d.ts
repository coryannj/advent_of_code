type Dispose<T> = (value: T) => unknown;
export interface LRUCacheOptions<T> {
    /**
     * The max time in millisecond to store items.
     *
     * @default Infinity
     */
    ttl?: number;
    /**
     * The max number of items to keep in the cache.
     *
     * @default Infinity
     */
    capacity?: number;
    /**
     * Method called when an item is removed from the cache
     */
    dispose?: Dispose<T>;
}
/**
 * A cache object support Least-Recently-Used and Time-To-Live elimination.
 *
 * # Alternatives
 * [lru-cache](https://github.com/isaacs/node-lru-cache)
 * [Mnemonist is a curated collection of data structures](https://github.com/yomguithereal/mnemonist)
 * [quick-lru](https://github.com/sindresorhus/quick-lru)
 */
export default class LRUCache<K, T> {
    private readonly map;
    private readonly ttl;
    private readonly dispose;
    private readonly capacity;
    constructor(options?: LRUCacheOptions<T>);
    /**
     * The number of items in the cache.
     */
    get size(): number;
    /**
     * Get an item stored in the cache.
     * Returns undefined if the item is not in the cache.
     */
    get(key: K): T | undefined;
    set(key: K, value: T): void;
    delete(key: K): void;
    /**
     * Delete all items from the cache.
     *
     * It's recommend to call this method when you no longer need the cache,
     * if the TTL is set.
     *
     * @param dispose override defaults on the constructor.
     */
    clear(dispose?: Dispose<T>): void;
    private refreshTimeout;
    private updateOrder;
    private pruneIfNeeded;
    [Symbol.iterator](): Generator<(K | T)[], void, unknown>;
    keys(): MapIterator<K>;
    values(): Generator<T, void, unknown>;
}
export {};
