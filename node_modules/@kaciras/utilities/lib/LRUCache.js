function firstItem(iterable) {
    for (const item of iterable)return item;
}
class MultiMap extends Map {
    get count() {
        let returnValue = 0;
        for (const [, v] of this){
            returnValue += v.length;
        }
        return returnValue;
    }
    *items() {
        for (const list of super.values())yield* list;
    }
    add(key, ...values) {
        const list = super.get(key);
        if (list) {
            list.push(...values);
        } else {
            super.set(key, [
                ...values
            ]);
        }
    }
    distribute(keys, ...values) {
        for (const key of keys){
            this.add(key, ...values);
        }
    }
    deleteItem(key, value) {
        const list = super.get(key);
        if (!list) return false;
        const i = list.indexOf(value);
        if (i === -1) return false;
        if (list.length === 1) {
            return super.delete(key);
        } else {
            return !!list.splice(i, 1);
        }
    }
    hasItem(key, value) {
        const list = super.get(key);
        return list ? list.indexOf(value) !== -1 : false;
    }
}
class UniqueMultiMap extends Map {
    get count() {
        let returnValue = 0;
        for (const [, v] of this){
            returnValue += v.size;
        }
        return returnValue;
    }
    *items() {
        for (const list of super.values())yield* list;
    }
    add(key, ...values) {
        const list = super.get(key);
        if (list) {
            for (const v of values){
                list.add(v);
            }
        } else {
            super.set(key, new Set(values));
        }
    }
    distribute(keys, ...values) {
        for (const key of keys){
            this.add(key, ...values);
        }
    }
    deleteItem(key, value) {
        const list = super.get(key);
        const removed = list?.delete(value);
        if (!removed) {
            return false;
        }
        if (list.size > 0) {
            return true;
        }
        return super.delete(key);
    }
    hasItem(key, value) {
        return !!super.get(key)?.has(value);
    }
}
function* cartesianObject(src) {
    const entries = Array.isArray(src) ? src : Object.entries(src);
    if (entries.length === 0) {
        yield {};
        return;
    }
    const state = new Array(entries.length);
    const end = state.length - 1;
    const template = {};
    let index = 0;
    while(index !== -1){
        const iterator = state[index] ??= entries[index][1][Symbol.iterator]();
        const { done, value } = iterator.next();
        if (done) {
            state[index--] = undefined;
            continue;
        }
        template[entries[index][0]] = value;
        if (index !== end) {
            index++;
        } else {
            yield {
                ...template
            };
        }
    }
}
function* cartesianArray(src) {
    if (src.length === 0) {
        yield [];
        return;
    }
    const state = new Array(src.length);
    const end = state.length - 1;
    const template = new Array(src.length);
    let index = 0;
    while(index !== -1){
        const iterator = state[index] ??= src[index][Symbol.iterator]();
        const { done, value } = iterator.next();
        if (done) {
            state[index--] = undefined;
            continue;
        }
        template[index] = value;
        if (index !== end) {
            index++;
        } else {
            yield [
                ...template
            ];
        }
    }
}

const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
};
function escapeHTML(html) {
    return html.replaceAll(/[&<>"']/g, (v)=>htmlEscapes[v]);
}
function unescapeHTML(html) {
    return html.replaceAll(/&(?:amp|lt|gt|quot|#39);/g, (v)=>htmlEscapes[v]);
}
const svgEscapes = {
    '"': "'",
    "%": "%25",
    "#": "%23",
    "{": "%7B",
    "}": "%7D",
    "<": "%3C",
    ">": "%3E"
};
function svgToUrl(svg) {
    return svg.replaceAll(/["%#{}<>]/g, (v)=>svgEscapes[v]);
}
function blobToBase64URL(blob) {
    return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = ()=>resolve(reader.result);
        reader.readAsDataURL(blob);
    });
}
const urlSafeMap = {
    "=": "",
    "/": "_",
    "+": "-"
};
function toUint8(buffer) {
    return ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
}
function base64url(buffer) {
    if (typeof window === "undefined") {
        if (!Buffer.isBuffer(buffer)) {
            buffer = Buffer.from(toUint8(buffer));
        }
        return buffer.toString("base64url");
    }
    const chars = Array.from(toUint8(buffer), (c)=>String.fromCodePoint(c));
    return btoa(chars.join("")).replaceAll(/[+/=]/g, (v)=>urlSafeMap[v]);
}
async function transformBuffer(buffer, tx) {
    const stream = new ReadableStream({
        start (controller) {
            controller.enqueue(buffer);
            controller.close();
        }
    });
    const readable = stream.pipeThrough(tx);
    return new Uint8Array(await new Response(readable).arrayBuffer());
}

function toBuf(value) {
    return typeof value === "string" ? new TextEncoder().encode(value) : value;
}
function sha256(data) {
    return crypto.subtle.digest("SHA-256", toBuf(data)).then(base64url);
}
class AESHelper {
    static DEFAULT_SALT = new Uint32Array([
        0xaf9a9c5c,
        0x8200982d,
        0x90f46814,
        0xf7008542,
        0xe7fb5613,
        0xc6b73dc1,
        0x00008be5,
        0x1eeb367d
    ]);
    static DEFAULT_IV = new Uint32Array([
        0x7f110357,
        0xaf05541a,
        0x36463f73,
        0x0df21a80,
        0xfd1b00fb,
        0x6e99d1c4,
        0xac27a23f,
        0x2aef0aeb
    ]);
    static async withPassword(password, options = {}) {
        const { iv = AESHelper.DEFAULT_IV, length = 128, iterations = 240537, salt = AESHelper.DEFAULT_SALT } = options;
        const keyMaterial = await crypto.subtle.importKey("raw", toBuf(password), "PBKDF2", false, [
            "deriveKey"
        ]);
        const key = await crypto.subtle.deriveKey({
            name: "PBKDF2",
            hash: "SHA-512",
            salt: toBuf(salt),
            iterations
        }, keyMaterial, {
            name: "AES-GCM",
            length
        }, false, [
            "encrypt",
            "decrypt"
        ]);
        return new AESHelper({
            name: "AES-GCM",
            iv
        }, key);
    }
    algorithm;
    key;
    constructor(algorithm, key){
        this.key = key;
        this.algorithm = algorithm;
    }
    async encrypt(input) {
        return await crypto.subtle.encrypt(this.algorithm, this.key, toBuf(input));
    }
    async decrypt(input) {
        return crypto.subtle.decrypt(this.algorithm, this.key, input);
    }
    async decryptText(input) {
        return this.decrypt(input).then((b)=>new TextDecoder().decode(b));
    }
}

const NeverAbort = {
    aborted: false,
    reason: undefined,
    get onabort () {
        return null;
    },
    set onabort (_){},
    throwIfAborted () {},
    dispatchEvent () {
        throw new Error("Not supported");
    },
    addEventListener () {},
    removeEventListener () {}
};
let uniqueIdCounter = 0;
function uniqueId() {
    return uniqueIdCounter += 1;
}
function pathPrefix(str, sep) {
    const i = str.lastIndexOf(sep);
    return i === -1 ? str : str.slice(0, i);
}
function pathSuffix(str, sep) {
    const i = str.lastIndexOf(sep);
    return i === -1 ? str : str.slice(i + 1);
}
function sleep(ms, signal = NeverAbort) {
    return new Promise((resolve, reject)=>{
        if (signal.aborted) {
            reject(signal.reason);
        }
        setTimeout(resolve, ms);
        signal.addEventListener("abort", ()=>reject(signal.reason));
    });
}
function getCached(cache, key, compute) {
    let value = cache.get(key);
    return value === undefined && cache.set(key, value = compute(key)), value;
}

class SingleEventEmitter {
    handlers = [];
    addListener(handler) {
        this.handlers.push(handler);
    }
    removeListener(handler) {
        const { handlers } = this;
        this.handlers = handlers.filter((h)=>h !== handler);
    }
    removeAllListeners() {
        this.handlers = [];
    }
    once(handler) {
        const wrapper = (...args)=>{
            handler.apply(this, args);
            this.removeListener(wrapper);
        };
        this.addListener(wrapper);
    }
    dispatchEvent(...args) {
        for (const handler of this.handlers)handler.apply(this, args);
    }
}
class MultiEventEmitter {
    events = Object.create(null);
    addListener(name, handler) {
        (this.events[name] ??= []).push(handler);
    }
    removeListener(name, handler) {
        let handlers = this.events[name];
        if (!handlers) {
            return;
        }
        handlers = handlers.filter((h)=>h !== handler);
        if (handlers.length === 0) {
            delete this.events[name];
        } else {
            this.events[name] = handlers;
        }
    }
    removeAllListeners(name) {
        if (name !== undefined) {
            delete this.events[name];
        } else {
            this.events = Object.create(null);
        }
    }
    once(name, handler) {
        const wrapper = (...args)=>{
            handler.apply(this, args);
            this.removeListener(name, wrapper);
        };
        this.addListener(name, wrapper);
    }
    dispatchEvent(name, ...args) {
        const handlers = this.events[name];
        for (const handler of handlers ?? [])handler.apply(this, args);
    }
}
function pubSub2ReqRes(publish, timeout = 0) {
    const txMap = new Map();
    function receive(message) {
        const session = txMap.get(message.r);
        if (session) {
            session.resolve(message);
            txMap.delete(message.r);
            clearTimeout(session.timer);
        }
    }
    async function request(message, transfer = []) {
        const s = message.s = uniqueId();
        let timer;
        if (timeout > 0) {
            timer = setTimeout(expire, timeout, s);
            if (typeof window === "undefined") {
                timer.unref();
            }
        }
        const response = new Promise((resolve, reject)=>{
            txMap.set(s, {
                resolve,
                reject,
                timer
            });
        });
        try {
            await publish(message, transfer);
            return response;
        } catch (publishError) {
            txMap.delete(s);
            clearTimeout(timer);
            throw publishError;
        }
    }
    function expire(sessionId) {
        const tx = txMap.get(sessionId);
        if (tx) {
            txMap.delete(sessionId);
            tx.reject(new Error("Receiving message timed out"));
        }
    }
    return {
        txMap,
        request,
        receive
    };
}

const alwaysTrue = ()=>true;
const alwaysFalse = ()=>false;
const identity = (v)=>v;
const noop = ()=>{};
const asyncNoop = async ()=>{};
const AsyncFunction = asyncNoop.constructor;
function silentCall(fn, ...args) {
    try {
        return fn(...args);
    } catch  {}
}
function silencePromise(value) {
    if (typeof value?.then === "function") value.catch(noop);
}
function createInstance(parent, value) {
    const proto = typeof parent === "function" ? parent.prototype : parent;
    return Object.assign(Object.create(proto), value);
}

async function fetchFile(input, init) {
    const url = typeof input === "string" ? input : input.url;
    const response = await fetch(input, init);
    if (!response.ok) {
        throw new Error(`Failed to fetch ${url} (${response.status})`);
    }
    const blob = await response.blob();
    const timeHeader = response.headers.get("last-modified");
    const lastModified = timeHeader ? new Date(timeHeader).getTime() : undefined;
    const name = new URL(url, "x://x").pathname.split("/").at(-1) || "downloaded";
    return new File([
        blob
    ], name, {
        type: blob.type,
        lastModified
    });
}
class FetchClientError extends Error {
    name = "FetchClientError";
    response;
    code;
    constructor(response, msg){
        super(msg ?? `Fetch failed. (${response.status})`);
        this.response = response;
        this.code = response.status;
    }
}
async function checkStatus(fetching) {
    const response = await fetching;
    if (response.ok) {
        return response;
    }
    throw new FetchClientError(response);
}
class ResponseFacade {
    raw;
    check;
    constructor(raw, check){
        this.raw = raw;
        this.check = check;
    }
    get unchecked() {
        return new ResponseFacade(this.raw, identity);
    }
    hasStatus(value) {
        return this.then((x)=>x.status === value);
    }
    json() {
        return this.then((x)=>x.json());
    }
    text() {
        return this.then((x)=>x.text());
    }
    get location() {
        return this.then((x)=>x.headers.get("location"));
    }
    get [Symbol.toStringTag]() {
        return "ResponseFacade";
    }
    catch(onRejected) {
        return this.check(this.raw).catch(onRejected);
    }
    finally(onFinally) {
        return this.check(this.raw).finally(onFinally);
    }
    then(onFulfilled, onRejected) {
        return this.check(this.raw).then(onFulfilled, onRejected);
    }
}
const defaultRequest = {
    credentials: "include"
};
class FetchClient {
    init;
    baseURL;
    check;
    doFetch;
    constructor(options = {}){
        this.init = options.init ?? defaultRequest;
        this.baseURL = options.baseURL ?? "";
        this.check = options.check ?? checkStatus;
        this.doFetch = options.fetch ?? fetch;
    }
    request(url, method, body, params) {
        const { baseURL, init, check, doFetch } = this;
        const headers = new Headers(init.headers);
        if (params) {
            const searchParams = new URLSearchParams();
            for (const k of Object.keys(params)){
                if (params[k] !== undefined) searchParams.set(k, params[k]);
            }
            url = `${url}?${searchParams}`;
        }
        if (body && typeof body === "object" && typeof body.append !== "function" && typeof body.text !== "function") {
            body = JSON.stringify(body);
            headers.set("content-type", "application/json");
        }
        const custom = {
            ...init,
            method,
            headers,
            body
        };
        const request = new Request(baseURL + url, custom);
        return new ResponseFacade(doFetch(request), check);
    }
    head(url, params) {
        return this.request(url, "HEAD", null, params);
    }
    get(url, params) {
        return this.request(url, "GET", null, params);
    }
    delete(url, params) {
        return this.request(url, "DELETE", null, params);
    }
    post(url, data, params) {
        return this.request(url, "POST", data, params);
    }
    put(url, data, params) {
        return this.request(url, "PUT", data, params);
    }
    patch(url, data, params) {
        return this.request(url, "PATCH", data, params);
    }
}

function ellipsis(value, length, position = "mid") {
    value = value.trim();
    if (value.length <= length) {
        return value;
    }
    let n = length - 1;
    switch(position){
        case "end":
            return value.slice(0, n) + "…";
        case "begin":
            return "…" + value.slice(-n);
        case "mid":
            n = Math.ceil(n / 2);
            return `${value.slice(0, n)}…${value.slice(-length + n + 1)}`;
    }
}
function separateThousand(text, separator = ",") {
    return text.replaceAll(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, separator);
}
function splitCLI(command) {
    const matches = command.matchAll(/"(.+?)(?<!\\)"|(\S+)/g);
    return Array.from(matches, ([, a, b])=>(a ?? b).replaceAll('\\"', '"'));
}
function buildCLI(...args) {
    return args.map(escapeCLIArg).join(" ");
}
function escapeCLIArg(argument) {
    argument = argument.replaceAll('"', '\\"');
    return /[\s|]/.test(argument) ? `"${argument}"` : argument;
}
function compositor(template, placeholders) {
    const nameToSlot = new Map();
    const positions = [];
    for (const name of Object.keys(placeholders)){
        const pattern = placeholders[name];
        let startPos;
        let endPos;
        if (typeof pattern === "string") {
            startPos = template.indexOf(pattern);
            if (startPos === -1) {
                throw new Error("No match for: " + pattern);
            }
            endPos = startPos + pattern.length;
        } else {
            const match = pattern.exec(template);
            if (!match) {
                throw new Error("No match for: " + pattern);
            }
            startPos = match.index;
            endPos = startPos + match[0].length;
        }
        positions.push({
            name,
            startPos,
            endPos
        });
    }
    positions.sort((a, b)=>a.startPos - b.startPos);
    let lastEnd = 0;
    const parts = [];
    for(let i = 0; i < positions.length; i++){
        const { name, startPos, endPos } = positions[i];
        nameToSlot.set(name, i * 2 + 1);
        if (startPos < lastEnd) {
            throw new Error("Placeholder overlapped.");
        }
        parts.push(template.slice(lastEnd, startPos));
        parts.push(template.slice(startPos, lastEnd = endPos));
    }
    parts.push(template.slice(lastEnd));
    return ()=>new Composite(nameToSlot, [
            ...parts
        ]);
}
class Composite {
    nameToSlot;
    parts;
    constructor(nameToSlot, parts){
        this.parts = parts;
        this.nameToSlot = nameToSlot;
    }
    toString() {
        return this.parts.join("");
    }
    put(name, value) {
        this.parts[this.nameToSlot.get(name)] = value;
    }
}

const SIZE_UNITS_SI = [
    "B",
    "KB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB",
    "ZB",
    "YB"
];
const DECIMAL_SYMBOLS = [
    "",
    "K",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
const DECIMAL_FRACTIONS = [
    1,
    1e3,
    1e6,
    1e9,
    1e12,
    1e15,
    1e18,
    1e21,
    1e24
];
const SIZE_UNITS_IEC = [
    "B",
    "KiB",
    "MiB",
    "GiB",
    "TiB",
    "PiB",
    "EiB",
    "ZiB",
    "YiB"
];
const BINARY_FRACTIONS = [
    1,
    1024,
    2 ** 20,
    2 ** 30,
    2 ** 40,
    2 ** 50,
    2 ** 60,
    2 ** 70,
    2 ** 80
];
const TIME_UNITS = [
    "ns",
    "us",
    "ms",
    "s",
    "m",
    "h",
    "d"
];
const TIME_FRACTIONS = [
    1,
    1e3,
    1e6,
    1e9,
    6e10,
    36e11,
    864e11
];
const groupRE = /[0-9.]+\s?([a-z]+)\s*/gi;
class UnitConvertor {
    name;
    sep;
    units;
    fractions;
    constructor(name, units, fractions, space = " "){
        this.name = name;
        this.sep = space;
        this.units = units;
        this.fractions = fractions;
    }
    getFraction(unit, base) {
        if (base !== undefined) {
            return this.getFraction(unit) / this.getFraction(base);
        }
        if (unit === undefined) {
            return 1;
        }
        const { units, fractions } = this;
        const i = units.indexOf(unit);
        if (i !== -1) {
            return fractions[i];
        }
        throw new Error(`Unknown ${this.name} unit: ${unit}`);
    }
    suit(value) {
        const s = this.fractions;
        let i = 0;
        while(s[i] <= value)i++;
        return Math.max(0, i - 1);
    }
    formatDiv(value, unit, precision = 2) {
        if (!Number.isFinite(value)) {
            throw new TypeError(`${value} is not a finite number`);
        }
        const { units, fractions } = this;
        let v = value * this.getFraction(unit);
        const i = this.suit(Math.abs(v));
        v /= fractions[i];
        return `${Number(v.toFixed(precision))}${this.sep}${units[i]}`;
    }
    homogeneous(values, unit) {
        const { fractions, units, sep } = this;
        let min = Infinity;
        for (const value of values){
            if (!value) {
                continue;
            }
            min = Math.min(min, Math.abs(value));
        }
        if (min === Infinity) {
            min = 0;
        }
        const x = this.getFraction(unit);
        const i = this.suit(min * x);
        const scale = x / fractions[i];
        const u = units[i];
        return {
            scale,
            unit: u,
            sep,
            format: (v, p = 2)=>(v * scale).toFixed(p) + sep + u
        };
    }
    formatMod(value, unit, parts = 2) {
        if (!Number.isFinite(value)) {
            throw new TypeError(`${value} is not a finite number`);
        }
        const { units, fractions } = this;
        let v = Math.abs(value) * this.getFraction(unit);
        const groups = [];
        for(let i = this.suit(v); i >= 0 && parts > 0; i--, parts -= 1){
            const f = fractions[i];
            if (v * f < 1) break;
            const t = Math.floor(v / f);
            v %= f;
            groups.push(`${t}${units[i]}`);
        }
        const sign = value < 0 ? "-" : "";
        return groups.length ? sign + groups.join(" ") : `0${unit}`;
    }
    parse(value, unit) {
        const { name, units, fractions } = this;
        let k = Infinity;
        let seen = 0;
        let result = 0;
        for (const [matched, u] of value.matchAll(groupRE)){
            const i = units.lastIndexOf(u, k);
            k = i - 1;
            if (i === -1) {
                throw new Error(units.includes(u) ? "Units must be ordered from largest to smallest" : `Unknown ${name} unit: ${u}`);
            }
            seen += matched.length;
            result += parseFloat(matched) * fractions[i];
        }
        switch(value.charCodeAt(0)){
            case 45:
                result = -result;
            case 43:
                seen += 1;
        }
        if (seen === value.length && seen > 0) {
            return result / this.getFraction(unit);
        }
        throw new Error(`Can not convert "${value}" to ${name}`);
    }
}
const durationFmt = new UnitConvertor("time", TIME_UNITS, TIME_FRACTIONS);
const decimalPrefix = new UnitConvertor("decimal prefix", DECIMAL_SYMBOLS, DECIMAL_FRACTIONS, "");
const dataSizeSI = new UnitConvertor("data size", SIZE_UNITS_SI, DECIMAL_FRACTIONS);
const dataSizeIEC = new UnitConvertor("data size", SIZE_UNITS_IEC, BINARY_FRACTIONS);

const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
async function invoke(send, path, args) {
    const transfers = [];
    for (const arg of args){
        const ts = transferCache.get(arg);
        if (ts) {
            transfers.push(...ts);
        }
    }
    const response = await send({
        p: path,
        a: args
    }, transfers);
    if (response) {
        if ("e" in response) throw response.e;
        else return response.v;
    }
}
async function serve(target, message) {
    const { s, p, a } = message;
    try {
        for(let k = p.length - 1; k > 0; k--){
            target = target[p[k]];
        }
        const v = await target[p[0]](...a);
        return [
            {
                r: s,
                v
            },
            transferCache.get(v) ?? []
        ];
    } catch (e) {
        return [
            {
                r: s,
                e
            },
            []
        ];
    }
}
function createServer(target, respond = noop) {
    return async (message)=>{
        if (Array.isArray(message.p)) {
            await respond(...await serve(target, message));
        }
    };
}
class RPCProxyHandler {
    path;
    constructor(path){
        this.path = path;
    }
    async apply(send, _, args) {
        return invoke(send, this.path, args);
    }
    get(send, key) {
        return new Proxy(send, new RPCProxyHandler([
            key,
            ...this.path
        ]));
    }
}
function createClient(sender, listen) {
    if (listen) {
        const { request, receive } = pubSub2ReqRes(sender);
        sender = request;
        listen(receive);
    }
    return new Proxy(sender, new RPCProxyHandler([]));
}
function probeSend(obj) {
    if ("send" in obj) {
        return (message)=>obj.send(message);
    } else if ("postMessage" in obj) {
        return obj.postMessage.bind(obj);
    } else if ("emit" in obj) {
        return (message)=>{
            obj.emit("message", message);
        };
    } else if ("dispatchEvent" in obj) {
        return (data)=>{
            obj.dispatchEvent(new MessageEvent("message", {
                data
            }));
        };
    } else {
        throw new TypeError("Can't find send method");
    }
}
function probeReceive(obj, callback) {
    if ("addEventListener" in obj) {
        obj.addEventListener("message", (e)=>callback(e.data));
    } else if ("on" in obj) {
        obj.on("message", callback);
    } else {
        throw new TypeError("Can't find response listener");
    }
}
function probeServer(target, receiver, sender) {
    const respond = sender === false ? noop : probeSend(sender ?? receiver);
    probeReceive(receiver, createServer(target, respond));
}
function probeClient(sender, receiver = sender) {
    const publish = probeSend(sender);
    if (receiver === false) {
        return createClient(publish);
    }
    const { request, receive } = pubSub2ReqRes(publish);
    probeReceive(receiver, receive);
    return createClient(request);
}

var rpc = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createClient: createClient,
	createServer: createServer,
	probeClient: probeClient,
	probeServer: probeServer,
	serve: serve,
	transfer: transfer
});

class LRUCache {
    map = new Map();
    ttl;
    dispose;
    capacity;
    constructor(options = {}){
        this.ttl = options.ttl ?? Infinity;
        this.capacity = options.capacity ?? Infinity;
        this.dispose = options.dispose ?? noop;
    }
    get size() {
        return this.map.size;
    }
    get(key) {
        const e = this.map.get(key);
        if (e) {
            this.updateOrder(key, e);
            this.refreshTimeout(key, e);
            return e.value;
        }
    }
    set(key, value) {
        let e = this.map.get(key);
        if (e) {
            this.dispose(e.value);
            e.value = value;
            this.updateOrder(key, e);
        } else {
            e = {
                value
            };
            this.map.set(key, e);
            this.pruneIfNeeded();
        }
        this.refreshTimeout(key, e);
    }
    delete(key) {
        const e = this.map.get(key);
        if (!e) {
            return;
        }
        this.map.delete(key);
        clearTimeout(e.timer);
        this.dispose(e.value);
    }
    clear(dispose) {
        dispose ??= this.dispose;
        for (const e of this.map.values()){
            dispose(e.value);
            clearTimeout(e.timer);
        }
        this.map.clear();
    }
    refreshTimeout(key, e) {
        const { ttl, map, dispose } = this;
        if (ttl === Infinity) {
            return;
        }
        clearTimeout(e.timer);
        const cb = ()=>{
            map.delete(key);
            dispose(e.value);
        };
        (e.timer = setTimeout(cb, ttl)).unref?.();
    }
    updateOrder(key, e) {
        this.map.delete(key);
        this.map.set(key, e);
    }
    pruneIfNeeded() {
        if (this.size <= this.capacity) {
            return;
        }
        const [key, e] = firstItem(this.map);
        this.map.delete(key);
        this.dispose(e.value);
        return clearTimeout(e.timer);
    }
    *[Symbol.iterator]() {
        for (const [key, e] of this.map)yield [
            key,
            e.value
        ];
    }
    keys() {
        return this.map.keys();
    }
    *values() {
        for (const e of this.map.values())yield e.value;
    }
}

export { AESHelper, AsyncFunction, Composite, FetchClient, FetchClientError, LRUCache, MultiEventEmitter, MultiMap, NeverAbort, ResponseFacade, SingleEventEmitter, UniqueMultiMap, UnitConvertor, alwaysFalse, alwaysTrue, asyncNoop, base64url, blobToBase64URL, buildCLI, cartesianArray, cartesianObject, compositor, createInstance, dataSizeIEC, dataSizeSI, decimalPrefix, durationFmt, ellipsis, escapeHTML, fetchFile, firstItem, getCached, identity, noop, pathPrefix, pathSuffix, pubSub2ReqRes, rpc, separateThousand, sha256, silencePromise, silentCall, sleep, splitCLI, svgToUrl, transformBuffer, unescapeHTML, uniqueId };
