import { OnFulfilled, OnRejected } from "./lang.ts";
/**
 * Fetch the resource into a File object, detect name and last modified from response.
 *
 * @param input This defines the resource that you wish to fetch.
 * @param init An object containing any custom settings that you want to apply to the request.
 */
export declare function fetchFile(input: RequestInfo, init?: RequestInit): Promise<File>;
/**
 * The HTTP request was successful but failed the application layer checks.
 */
export declare class FetchClientError extends Error {
    name: string;
    readonly response: Response;
    readonly code: number;
    constructor(response: Response, msg?: string);
}
type Check = (promise: Promise<Response>) => Promise<Response>;
/**
 * Wrapper for Promise<Response>, provide status checking and useful method alias.
 *
 * @example
 * // await it will check the response status.
 * try {
 *     const response = await client.get(...);
 *     assert(response.ok);
 * } catch (e) {
 *     console.error(e.message);
 * }
 *
 * // Get the response body in JSON format.
 * const data = await client.get(...).json<Type>();
 *
 * // Get raw response without status checking.
 * const response = await client.get(...).unchecked;
 *
 * // Get the Location header.
 * const location = await apiService.get(...).location;
 */
export declare class ResponseFacade implements Promise<Response> {
    private readonly raw;
    private readonly check;
    constructor(raw: Promise<Response>, check: Check);
    /**
     * Get the ResponseFacade for the same response, without any checks.
     */
    get unchecked(): ResponseFacade;
    /**
     * Convenience method for status checking, resolved to true if the response
     * status is equals to the value, otherwise false.
     *
     * Note: The status may be checked before and throw an error,
     * to avoid this you can use `.unchecked.hasStatus(...)`.
     */
    hasStatus(value: number): Promise<boolean>;
    /**
     * Convenience method for parse the JSON body.
     *
     * Advantages over Response.json():
     * 1) Prefer generic `res.json<T>()` over casting `res.json() as T`.
     * 2) Using this method can eliminate a then/await call.
     */
    json<T = any>(): Promise<T>;
    text(): Promise<string>;
    get location(): Promise<string>;
    get [Symbol.toStringTag](): string;
    catch<E = never>(onRejected: OnRejected<E>): Promise<Response | E>;
    finally(onFinally?: (() => void) | null): Promise<Response>;
    then<T = Response, R = never>(onFulfilled?: OnFulfilled<Response, T>, onRejected?: OnRejected<R>): Promise<T | R>;
}
type ResolvedFetch = (request: Request) => Promise<Response>;
/**
 * Query parameters of the URL, value will be converted to string using toString().
 */
type Params = Record<string, any>;
export interface FetchClientOptions {
    /**
     * `baseURL` will be prepended to `url` if present.
     */
    baseURL?: string;
    /**
     * Check response status before retrieving data.
     * By default, it rejects the promise if status is not 2xx.
     */
    check?: Check;
    /**
     * Use custom implementation instead of `global.fetch`.
     */
    fetch?: ResolvedFetch;
    /**
     * Custom settings that you want to apply to each request.
     */
    init?: RequestInit;
}
/**
 * A very simple helper to make `fetch` easier.
 *
 * # Alternatives
 * [redaxios](https://github.com/developit/redaxios)
 * [ky](https://github.com/sindresorhus/ky)
 * [axios](https://github.com/axios/axios)
 * [wretch](https://github.com/elbywan/wretch)
 *
 * @example
 * const client = new FetchClient({ baseURL: "https://example.com" });
 * const html = await client.get("/foo?bar=baz").text();
 */
export declare class FetchClient {
    protected readonly init: RequestInit;
    protected readonly baseURL: string;
    protected readonly check: Check;
    protected readonly doFetch: ResolvedFetch;
    constructor(options?: FetchClientOptions);
    request(url: string, method?: string, body?: any, params?: Params): ResponseFacade;
    head(url: string, params?: Params): ResponseFacade;
    get(url: string, params?: Params): ResponseFacade;
    delete(url: string, params?: Params): ResponseFacade;
    post(url: string, data?: any, params?: Params): ResponseFacade;
    put(url: string, data?: any, params?: Params): ResponseFacade;
    patch(url: string, data?: any, params?: Params): ResponseFacade;
}
export {};
