type BufferOrString = BufferSource | string;
/**
 * A convenient hash function using SHA-256.
 *
 * @param data the data to be digested.
 * @return Url-safe base64 encoded digest string.
 */
export declare function sha256(data: BufferOrString): Promise<string>;
interface AESOptions {
    /**
     * AES key size, can be 128, 192, or 256.
     *
     * @default 128
     */
    length?: 128 | 192 | 256;
    /**
     * GCM initialization vector.
     *
     * @default AESHelper.DEFAULT_IV
     */
    iv?: BufferSource;
    /**
     * @default AESHelper.DEFAULT_SALT
     */
    salt?: BufferOrString;
    /**
     * Number of iterations used for PBKDF2.
     *
     * @default 240537
     */
    iterations?: number;
}
/**
 * A simple WebCrypto wrapper for symmetric encryption with sensible defaults.
 *
 * Currently, WebCrypto does not support streams. Further reading:
 * https://github.com/w3c/webcrypto/issues/73
 *
 * On browser, this class is only available in secure contexts (HTTPS).
 * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto
 *
 * @example
 * const aes = await AESHelper.withPassword("foobar");
 * const encrypted = await aes.encrypt("123456");
 * const plain = await aes.decryptText(encrypted); // "123456"
 */
export declare class AESHelper {
    static readonly DEFAULT_SALT: Uint32Array;
    static readonly DEFAULT_IV: Uint32Array;
    static withPassword(password: BufferOrString, options?: AESOptions): Promise<AESHelper>;
    private readonly algorithm;
    private readonly key;
    private constructor();
    encrypt(input: BufferOrString): Promise<ArrayBuffer>;
    decrypt(input: BufferSource): Promise<ArrayBuffer>;
    /**
     * Decrypt data and convert it to string using utf8 encoding.
     */
    decryptText(input: BufferSource): Promise<string>;
}
export {};
