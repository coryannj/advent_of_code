import { PostMessage } from "./event.ts";
import { Awaitable } from "./lang.ts";
/**
 * By default, every function parameter, return value and object property value is copied,
 * in the sense of structured cloning.
 *
 * If you want a value to be transferred rather than copied,
 * you can wrap the value in a transfer() call and provide a list of transferable values:
 *
 * @example
 * const data = new Uint8Array([1, 2, 3, 4, 5]);
 * await client.someFunction(transfer(data, [data.buffer]));
 *
 * @param obj The object contains transferable values.
 * @param transfers List of values to transfer.
 */
export declare function transfer<T>(obj: T, transfers: Transferable[]): T;
export interface RequestMessage {
    a: unknown[];
    p: PropertyKey[];
    s?: number;
}
export type ResponseMessage = ({
    v: unknown;
} | {
    e: unknown;
}) & {
    r?: number;
};
export type Publish = PostMessage<RequestMessage>;
export type Respond = PostMessage<ResponseMessage>;
export type Communicate = (message: RequestMessage, transfer: Transferable[]) => Awaitable<ResponseMessage>;
export type SendFn = Publish | Communicate;
type ServeResultTuple = [ResponseMessage, Transferable[]];
/**
 * Handle an RPC request, call specific method in the target.
 *
 * This function can be used for request-response model.
 *
 * @example
 * // Create RPC server on http://localhost:9789
 * import consumers from "stream/consumers";
 * import { RPC } from "@kaciras/utilities/browser";
 *
 * const functions = {
 * 		hello: (name: string) => `Hello ${name}!`,
 * };
 *
 * const server = http.createServer((req, res) => {
 * 		consumers.json(req)
 * 			.then(msg => RPC.serve(functions, msg))
 * 			.then(d => res.end(JSON.stringify(d[0])));
 * });
 *
 * server.listen(9789);
 *
 * @param target The service object contains methods that client can use.
 * @param message RPC request message.
 */
export declare function serve(target: any, message: RequestMessage): Promise<ServeResultTuple>;
/**
 * A simple wrapper for `RPC.serve`, used to serve requests with
 * publish-subscribe channel.
 *
 * @example
 * // Serve RPC requests in web worker.
 * import { RPC } from "@kaciras/utilities/browser";
 *
 * const functions = {
 * 	hello: (name: string) => `Hello ${name}!`,
 * };
 *
 * const handle = RPC.createServer(functions, (msg, transfer) => {
 * 	self.postMessage(msg, { transfer });
 * });
 * self.addEventListener("message", msg => handle(msg.data));
 */
export declare function createServer(target: any, respond?: Respond): (message: RequestMessage) => Promise<void>;
/**
 * Takes a type and wraps it in a Promise, if it not already is one.
 * This is to avoid `Promise<Promise<T>>`.
 *
 * This is the inverse of `Awaited<T>`.
 */
type Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;
type RemoteProperty<T> = T extends Function ? RemoteCallable<T> : T extends object ? Remote<T> : T;
export type Remote<T> = {
    [P in keyof T]: RemoteProperty<T[P]>;
};
type RemoteCallable<T> = T extends (...args: infer A) => infer R ? (...args: A) => Promisify<Awaited<R>> : unknown;
export type VoidRemote<T> = {
    [P in keyof T]: VoidRemoteProperty<T[P]>;
};
type VoidRemoteProperty<T> = T extends Function ? VoidCallable<T> : T extends object ? VoidRemote<T> : T;
type VoidCallable<T> = T extends (...args: infer A) => any ? (...args: A) => Promise<void> : unknown;
export type Listen = (callback: (message: ResponseMessage) => void) => void;
/**
 * Create an RPC client with request-response channel.
 *
 * @example
 * // Call remote function `hello` with HTTP protocol.
 * import { RPC } from "@kaciras/utilities/browser";
 *
 * const client = RPC.createClient(async message => {
 *     const response = await fetch("http://localhost:9789", {
 *         method: "POST",
 *         body: JSON.stringify(message),
 *     });
 *     if (response.ok) {
 *         return response.json();
 *     } else {
 *         throw new Error("fetch failed: " + response.status);
 *     }
 * });
 *
 * expect(await client.hello("world")).toBe("Hello world!");
 *
 * @param send Function to post request message and receive response message.
 */
export declare function createClient<T = any>(send: Communicate): Remote<T>;
/**
 * Create an RPC client with publish-subscribe channel.
 *
 * @example
 * // create RPC client with a web worker.
 * import { RPC } from "@kaciras/utilities/browser";
 *
 * const worker = new Worker("/worker.js");
 * const post = worker.postMessage.bind(worker);
 * const client = RPC.createClient(post, callback => {
 * 	worker.onmessage = e => callback(e.data);
 * });
 *
 * @param send Function to post request message.
 * @param listen Listener to receive response message.
 */
export declare function createClient<T = any>(send: Publish, listen: Listen): Remote<T>;
/**
 * Create an RPC client with one-way message sender.
 *
 * In this case the client cannot receive results of remote functions, returned
 * promise of methods are resolved after message sent.
 *
 * @example
 * import { RPC } from "@kaciras/utilities/browser";
 * const client = RPC.createClient(process.send);
 *
 * // call remote function, but not care the result.
 * await client.hello("world");
 */
export declare function createClient<T = any>(send: Publish): VoidRemote<T>;
/**
 * Serve RPC requests, the post & receive methods are auto-detected from parameters.
 *
 * @example
 * probeServer(APIs, globalThis);	// In WebWorker, child processes.
 *
 * import {parentPort} from "worker_threads";
 * probeServer(APIs, parentPort);	// In worker threads.
 *
 * @param target The service object contains methods that client can use.
 * @param sender The object contains receive method.
 * @param receiver The object contains post method,
 * 				   set to false prevents the server to send response.
 */
export declare function probeServer(target: any, receiver: object, sender?: object | false): void;
/**
 * Create an RPC client, the post & receive methods are auto-detected from parameters.
 *
 * @example
 * probeClient(new Worker("...")).hello();
 *
 * import { fork } from "child_process"
 * probeClient(fork("...")).hello();
 *
 * @param sender The object provides the post method.
 * @param receiver The object provides the receive method, default is same as the sender.
 */
export declare function probeClient<T = any>(sender: object, receiver?: object): Remote<T>;
/**
 * When receiver is set to false, the client runs in one-way mode.
 */
export declare function probeClient<T = any>(sender: object, receiver: false): VoidRemote<T>;
export {};
