type Handler<T, A extends any[]> = (this: T, ...args: A) => unknown;
/**
 * Event dispatcher for only one type of event.
 *
 * Listeners are called synchronously in the order in which
 * they were registered.
 */
export declare class SingleEventEmitter<A extends any[] = any[]> {
    private handlers;
    addListener(handler: Handler<this, A>): void;
    /**
     * Removes the specified listener from the listener array.
     *
     * Once an event is emitted, all listeners attached to it
     * at the time of emitting are called in order.
     * This implies that any removeListener() or removeAllListeners()
     * calls after emitting and before the last listener
     * finishes execution will not remove them from emit() in progress.
     *
     * @param handler The listener to remove
     */
    removeListener(handler: Handler<this, A>): void;
    removeAllListeners(): void;
    once(handler: Handler<this, A>): void;
    dispatchEvent(...args: A): void;
}
/** Event name with its arguments */
type EventMap = Record<string | symbol, any[]>;
interface Default extends EventMap {
    [event: string]: any[];
}
/**
 * Emit multiple type events and may have listeners for them.
 *
 * # Alternatives
 * [nanoevents](https://github.com/ai/nanoevents).
 *
 * In Node, you can import EventEmitter from "event" instead.
 */
export declare class MultiEventEmitter<T extends EventMap = Default> {
    private events;
    addListener<K extends keyof T>(name: K, handler: Handler<this, T[K]>): void;
    removeListener<K extends keyof T>(name: K, handler: Handler<this, T[K]>): void;
    removeAllListeners(name?: keyof T): void;
    once<K extends keyof T>(name: K, handler: Handler<this, T[K]>): void;
    dispatchEvent<K extends keyof T>(name: K, ...args: T[K]): void;
}
/**
 * Sends a message. If the function return a Promise, it should be awaited.
 */
export type PostMessage<T = any> = (message: T, transfer: Transferable[]) => void;
interface PromiseController<T = unknown> {
    timer?: ReturnType<typeof setTimeout>;
    resolve(value: T): void;
    reject(reason: unknown): void;
}
interface RequestResponseWrapper<T, R> {
    txMap: Map<number, PromiseController<R>>;
    receive(message: R): void;
    request(message: T, transfer?: Transferable[]): Promise<R>;
}
type ReqIdMixin = object & {
    s?: number;
};
type ResIdMixin = object & {
    r?: number;
};
/**
 * Wrap publish-subscribe functions to request-response model.
 *
 * # NOTE
 * If you disable timeout, there will be a memory leak when response
 * message can't be received. WeakMap doesn't help in this scenario,
 * since the key is deserialized from the message.
 *
 * @example
 * const { request, receive } = pubSub2ReqRes(window.postMessage);
 * window.addEventListener("message", e => receive(e.data));
 * const response = await request({ text: "Hello" });
 *
 * @param publish The publish message function
 * @param timeout The number of milliseconds to wait for response,
 * 				  set to zero or negative value to disable timeout.
 */
export declare function pubSub2ReqRes<T extends ReqIdMixin = any, R extends ResIdMixin = any>(publish: PostMessage<T>, timeout?: number): RequestResponseWrapper<T, R>;
export {};
