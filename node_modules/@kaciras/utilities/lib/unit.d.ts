/**
 * Formatter to format values into string in the specific unit.
 */
export interface HomogeneousUC {
    unit: string;
    scale: number;
    sep: string;
    format: (value: number, precision?: number) => string;
}
export declare class UnitConvertor<T extends readonly string[] = readonly string[]> {
    private readonly name;
    private readonly sep;
    /**
     * Supported units of this convertor, from small to large.
     */
    readonly units: T;
    /**
     * Parallel array of `units`, containing the magnification
     * relative to the smallest unit.
     */
    readonly fractions: number[];
    constructor(name: string, units: T, fractions: number[], space?: string);
    /**
     * Get the fraction of the unit based on another.
     * If any parameter is undefined, it equals to the minimum unit.
     *
     * @example
     * dataSizeSI.getFraction("TB");		// 1e12
     * dataSizeSI.getFraction("TB", "MB");	// 1e6
     * dataSizeSI.getFraction("MB", "TB");	// 1e-6
     *
     * @throws Error If a parameter is not in the `units` property.
     */
    getFraction(unit?: string, base?: string): number;
    /**
     * Find the index of the largest fraction that is less than the value.
     *
     * @example
     * durationFmt.suit(1200_000);	// 2 (.units[2] === "ms")
     * durationFmt.suit(0);			// 0 (.units[0] === "ns")
     * durationFmt.suit(999e12);	// 6 (.units[6] === "d")
     *
     * @param value A positive number. If it's likely to be negative, use Math.abs first.
     */
    private suit;
    /**
     * Scale the number to the most appropriate unit and round.
     * The result may lose precision and cannot be converted back.
     *
     * @example
     * durationFmt.formatDiv(0.1, "ns");		// "0.1 ns"
     * durationFmt.formatDiv(0, "s");			// "0 ns"
     * durationFmt.formatDiv(97215, "s", 4);	// "1.1252 d"
     * durationFmt.formatDiv(0.522, "h");		// "31.32 m"
     * durationFmt.formatDiv(0.522, "h", 1);	// "31.3 m"
     * durationFmt.formatDiv(0.522, "h", 99);	// "31.32 m"
     *
     * @param value Numeric value to use.
     * @param unit Unit ot the value.
     * @param precision The number of digits to appear after the decimal point.
     */
    formatDiv(value: number, unit?: T[number], precision?: number): string;
    /**
     * Iterate over values and find a minimum unit such that the values are
     * not less than 1 in that unit, then return a function to format value with the unit.
     *
     * The format function preserve trailing zeros.
     *
     * @example
     * const format = dataSizeSI.homogeneous([1200, 1e13], "KB");
     * format(1200);	// 1.20 MB
     * format(120);		// 0.12 MB
     * format(12);		// 0.01 MB
     * format(-120);	// -0.12 MB
     *
     * @param values The values used to calculate unit.
     * @param unit The unit of numbers in the values array, default is the minimum unit.
     */
    homogeneous(values: Iterable<number | undefined>, unit?: T[number]): HomogeneousUC;
    /**
     * Formats a value with unit into multiple groups.
     * The result may lose precision and cannot be converted back.
     *
     * @example
     * durationFmt.formatMod(0.1, "ns");		// "0ns"
     * durationFmt.formatMod(0, "s");			// "0s"
     * durationFmt.formatMod(97215, "s", 4);	// "1d 3h 0m 15s"
     * durationFmt.formatMod(0.522, "h");		// "31m 19s"
     * durationFmt.formatMod(0.522, "h", 1);	// "31m"
     * durationFmt.formatMod(0.522, "h", 99);	// "31m 19s 200ms"
     *
     * @param value Numeric value to use.
     * @param unit Unit ot the value.
     * @param parts Maximum number of groups in result.
     */
    formatMod(value: number, unit?: T[number], parts?: number): string;
    /**
     * Convert string to number in specified unit.
     *
     * @example
     * durationFmt.parse("10000d", "d");		// 10000
     * durationFmt.parse("0h", "s");			// 0
     * durationFmt.parse("0.5m", "s");			// 30
     * durationFmt.parse("1d 3h 0m 15s", "s");	// 97215
     * durationFmt.parse("+1d 3h 0m 15s", "s");	// 97215
     * durationFmt.parse("-1d 3h 0m 15s", "s");	// -97215
     *
     * @param value The string to parse.
     * @param unit Target unit to converted to.
     */
    parse(value: string, unit?: T[number]): number;
}
/**
 * Convert between duration and human-readable string.
 * Support units from nanoseconds to days.
 */
export declare const durationFmt: UnitConvertor<readonly ["ns", "us", "ms", "s", "m", "h", "d"]>;
/**
 * Convert between number and decimal prefixed number.
 *
 * @example
 * decimalPrefix.formatDiv(123456789); // 123.46M
 */
export declare const decimalPrefix: UnitConvertor<readonly ["", "K", "M", "G", "T", "P", "E", "Z", "Y"]>;
/**
 * Convert between bytes and human-readable string using SI (1000) prefixes.
 */
export declare const dataSizeSI: UnitConvertor<readonly ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]>;
/**
 * Convert between bytes and human-readable string using IEC (1024) prefixes.
 */
export declare const dataSizeIEC: UnitConvertor<readonly ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]>;
